[{"categories":["Unity","SpringBone"],"content":"实现现实中柔顺头发的效果 三个主要类：SpringBone、SpringCollider、SpringManager ","date":"4994-40-48","objectID":"/springbone/:0:0","tags":["SpringBone"],"title":"Spring Bone","uri":"/springbone/"},{"categories":["Unity","SpringBone"],"content":"SpringBone用于挂载到所有的骨骼上，最末端骨骼不需要挂载，需要保留原始动画的骨骼也不要挂载。 Child：下一个骨骼节点 Bone Axis：骨骼方向 Radius：骨骼的碰撞半径（仅对于spring collider的碰撞 Is Use Each Bone Force Settings：是否使用“弹簧骨骼”自己的Stiffness Force和Drag Force属性，而不是用SpringManager的设置。 Stiffness Force：弹簧回弹力 Drag Force：阻尼力 Spring Force：在世界坐标系下，作用在Spring Bone上的一个力；可以用来模拟重力或风力 Threshold：与SpringManager组件的Dynamic Ratio配合使用 Colliders：与自己发生碰撞的SpringCollider Debug ","date":"4994-40-48","objectID":"/springbone/:1:0","tags":["SpringBone"],"title":"Spring Bone","uri":"/springbone/"},{"categories":["Unity","SpringBone"],"content":"SpringMnager用于挂载到GameObject的Root节点上。 Dynamic Ratio：这个需要配合Spring Bone的Threshold来使用，对于每一个Spring Bone来说，当Threshold小于Dynamic Ratio时，Spring Bone才更新，否则是不更新的。 Stiffness Force：弹簧回弹力 Stiffness Curve：弹簧回弹力曲线 Drag Force：阻尼力 Drag Curve：阻尼力曲线 Spring Bones ","date":"4994-40-48","objectID":"/springbone/:2:0","tags":["SpringBone"],"title":"Spring Bone","uri":"/springbone/"},{"categories":["Unity","SpringBone"],"content":"SpringCollider可以阻挡SpringBone穿过的区域 ","date":"4994-40-48","objectID":"/springbone/:3:0","tags":["SpringBone"],"title":"Spring Bone","uri":"/springbone/"},{"categories":["前置知识","高等数学"],"content":"常见因式分解 展开 分解 a^2 − b^2 (a+b)(a−b) a^2 + 2ab + b^2 (a+b)(a+b) a^2 − 2ab + b^2 (a−b)(a−b) a^3 + b^3 (a+b)(a^2−ab+b^2) a^3 − b^3 (a−b)(a^2+ab+b^2) a^3 + 3a^2b + 3ab^2 + b^3 (a + b)^3 a^3 − 3a^2b + 3ab^2 − b^3 (a − b)^3 ","date":"4994-40-48","objectID":"/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/:1:0","tags":["前置知识"],"title":"前置知识","uri":"/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/"},{"categories":["前置知识","高等数学"],"content":"十字相乘$$ \\begin{aligned} ?\u0026=12x^2 - 17x + 6\\ \u0026步骤1:拆分12与6，使得它们交叉相乘的乘积值和为第二项系数\\ \u0026\\begin{vmatrix} 12\u00266\\ \u0026\\ 3\u0026-2\\ 4\u0026-3\\ \\end{vmatrix}\\ \u0026=(3x - 2)(4x - 3) \\end{aligned} $$ ","date":"4994-40-48","objectID":"/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/:2:0","tags":["前置知识"],"title":"前置知识","uri":"/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/"},{"categories":["前置知识","高等数学"],"content":"配方法$$ \\begin{aligned} ?\u0026 = 2x^2 + 5x - 3 \\ \u0026步骤1：前两项提取公因子，使第一项x^2系数为1\\ \u0026 = 2(x^2 + \\frac{5}{2}x) - 3\\ \u0026步骤2：将x^2指数提取到括号外面，同时也去掉第二项的x\\ \u0026 = 2(x + \\frac{1}{2} * \\frac{5}{2})^2 - 3\\ \u0026 = 2(x + \\frac{5}{4})^2 - 3\\ \u0026步骤3：在末尾减去第二项的幂以及括号前的系数\\ \u0026 = 2(x + \\frac{5}{4})^2 - 3 - (2 * (\\frac{5}{4})^2)\\ \u0026 = 2(x + \\frac{5}{4})^2 - 3 - \\frac{25}{8}\\ \u0026 = 2(x + \\frac{5}{4})^2 - \\frac{49}{8}\\ \\end{aligned} $$ ","date":"4994-40-48","objectID":"/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/:3:0","tags":["前置知识"],"title":"前置知识","uri":"/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/"},{"categories":["前置知识","高等数学"],"content":"分离常数法将分子中的x凑成分母形式，分离常数。 $$ \\begin{aligned} ?\u0026=\\frac{2x + 3}{3x - 4}\\ \u0026步骤1：将分子中的x替换成分母后，原先的2x成了3x，所以乘以\\frac{2}{3}\\ \u0026此时分子中还多减了\\frac{8}{3},所以分子中还需要加上\\frac{8}{3}\\ \u0026=\\frac{\\frac{2}{3} (3x-4)+ \\frac{8}{3} + 3}{3x-4}\\ \u0026=\\frac{2}{3} + \\frac{17}{3} * \\frac{1}{3x-4}\\ \\end{aligned} $$ 例2 $$ \\begin{aligned} ?\u0026=\\frac{2x^2 + 3x + 1}{(2x - 1)^2}\\ \u0026步骤1:将分子x替换成分母（不要带指数）\\ \u0026\\frac{(2x - 1)^2 + 3x + 1}{(2x - 1)^2} = \\frac{4x^2 - 2x - 2x + 1^2 + 3x + 1}{(2x - 1)^2} = \\frac{4x^2 - 4x +1 + 3x + 1}{(2x - 1)^2}\\ \u0026=\\frac{ \\frac{1}{2} * (2x - 1)^2 +2x - \\frac{1}{2} + 3x + 1}{(2x - 1)^2} = \\frac{ \\frac{1}{2} * (2x - 1)^2 + 5x + \\frac{1}{2}}{(2x - 1)^2}\\ \u0026=\\frac{1}{2} + \\frac{5x + \\frac{1}{2}}{(2x - 1)^2}\\ \u0026把5x替换成分母\\ \u0026\\frac{1}{2} + \\frac{(2x - 1) + \\frac{1}{2}}{(2x - 1)^2}\\ \u0026=\\frac{1}{2} + \\frac{ \\frac{5}{2} (2x - 1) + \\frac{5}{2} + \\frac{1}{2}}{(2x - 1)^2}\\ \u0026=\\frac{1}{2} + \\frac{5}{2} * \\frac{1}{(2x-1)} + \\frac{3}{(2x - 1)^2}\\ \u0026=\\frac{1}{2} + \\frac{5}{2} * \\frac{1}{(2x-1)} + 3*\\frac{1}{(2x - 1)^2} \\end{aligned} $$ ","date":"4994-40-48","objectID":"/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/:4:0","tags":["前置知识"],"title":"前置知识","uri":"/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/"},{"categories":["前置知识","高等数学"],"content":"绝对值不等式小于取中间，大于取两边。 例1: $$ |2x + 1| \u003c 3\\ -3 \u003c 2x + 1 \u003c 3\\ -4 \u003c 2x \u003c 2\\ -2 \u003c x \u003c 1 $$ 例2: $$ |1 - 2x| \u003e 5\\ |2x - 1| \u003e 5\\ 2x - 1 \u003c -5或2x - 1 \u003e 5\\ x \u003c -2或x \u003e 3 $$ ","date":"4994-40-48","objectID":"/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/:5:0","tags":["前置知识"],"title":"前置知识","uri":"/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/"},{"categories":["前置知识","高等数学"],"content":"二次不等式 常见结论 $$ x^2 \u003c a(a \\geq 0) \\Longrightarrow |x| \u003c \\sqrt{a}\\ x^2 \u003e a(a \\geq 0) \\Longrightarrow |x| \u003e \\sqrt{a}\\ x^2 \u003c a(a \u003c 0) \\Longrightarrow x \\in \\empty\\ x^2 \u003e a(a \u003c 0) \\Longrightarrow x \\in \\mathbb{R}\\ $$ 配方法-例1: $$ -x^2 + x + 2 \u003c 0 $$ 配方法-例2: $$ 2x^2 + 5x - 3 \u003c 0\\ 2(x^2 + \\frac{5}{2}x) - 3 \u003c 0\\ 2(x + \\frac{1}{2} * \\frac{5}{2})^2 - 3 - 2*(\\frac{1}{2} * \\frac{5}{2})^2 \u003c 0\\ 2(x + \\frac{5}{4})^2 - 3 - \\frac{25}{8} \u003c 0\\ 2(x + \\frac{5}{4})^2 \u003c \\frac{49}{8}\\ (x + \\frac{5}{4})^2 \u003c \\frac{49}{16}\\ \\left|x + \\frac{5}{4}\\right| \u003c \\frac{7}{4}\\ -\\frac{7}{4} \u003c x + \\frac{5}{4} \u003c \\frac{7}{4}\\ -3 \u003c x \u003c \\frac{1}{2}\\ $$ 因式分解法-例1: $$ x^2 - x - 2 \u003c 0 $$ 因式分解法-例2: $$ 2x^2 + 5x -3 \\geq 0 $$ 因式分解法-例3: $$ -5 \\leq 2x^2 + 5x -3 \u003c 0 $$ ","date":"4994-40-48","objectID":"/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/:6:0","tags":["前置知识"],"title":"前置知识","uri":"/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/"},{"categories":["前置知识","高等数学"],"content":"倒数不等式常见结论 $$ \\begin{aligned} (1)\u0026\\frac{1}{\\pm\\infty}=0， \\frac{1}{0^-}=-\\infty， \\frac{1}{0^+}=+\\infty\\ (2)\u0026x \\in (a,b),0 \\notin(a,b)\\\\ \u0026\\Longrightarrow \\frac{1}{x} \\in(\\frac{1}{b},\\frac{1}{a})\\\\ (3)\u0026x \\in(a,b),0 \\in(a,b)\\\\ \u0026\\Longrightarrow x \\in(a,0^-) \\cup (0^+,b)\\\\ \u0026\\Longrightarrow \\frac{1}{x} \\in(\\frac{1}{0^-},\\frac{1}{a})\\cup(\\frac{1}{b},\\frac{1}{0^+})\\\\ \u0026\\Longrightarrow \\frac{1}{x} \\in(-\\infty,\\frac{1}{a}) \\cup (\\frac{1}{b},+\\infty) \\end{aligned}\\ $$ ","date":"4994-40-48","objectID":"/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/:7:0","tags":["前置知识"],"title":"前置知识","uri":"/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/"},{"categories":["前置知识","高等数学"],"content":"均值不等式","date":"4994-40-48","objectID":"/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/:8:0","tags":["前置知识"],"title":"前置知识","uri":"/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/"},{"categories":["高等数学"],"content":"集合","date":"4994-40-48","objectID":"/%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/:1:0","tags":["集合与映射"],"title":"函数与极限","uri":"/%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/"},{"categories":["高等数学"],"content":"名次解释 集合：具有某种性质的元素的全体。 元素：集合中的每一个。 有限集合 无限集合 ","date":"4994-40-48","objectID":"/%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/:1:1","tags":["集合与映射"],"title":"函数与极限","uri":"/%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/"},{"categories":["高等数学"],"content":"集合表示大写字母表示集合A、B 用小写字母表示元素a、b $$ 元素a属于集合A:a \\in A\\ 元素b不属于集合A:b \\notin A $$ 集合表示方法-列举法 $$ \\mathbb{A}=\\left{a_1,a_2,a_3\\right} $$ 集合表示方法-描述法 $$ \\mathbb{M}=\\left{x \\middle| x具有的性质p\\right} $$ 特殊集合表示 $$ 实数集合:\\ \\mathbb{R}=\\left{所有的实数\\right}\\ 整数集合:\\ \\mathbb{Z}=\\left{\\cdots,-n,\\cdots,-2,-1,0,1,2,\\cdots,n,\\cdots\\right}\\ 自然数集合:\\ \\mathbb{N}=\\left{0,1,2,3,n,\\cdots\\right}\\ 正自然数集合:\\ \\mathbb{N^+}=\\left{1,2,3,n,\\cdots\\right}\\ 有理数集合:\\ \\mathbb{Q}=\\left{\\frac{p}{q}\\middle| p\\in \\mathbb{Z},q \\in \\mathbb{N^+},p与q互质 \\right}\\ $$ ","date":"4994-40-48","objectID":"/%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/:1:2","tags":["集合与映射"],"title":"函数与极限","uri":"/%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/"},{"categories":["高等数学"],"content":"集合之间的关系$$ A包含在B里\\ A \\subset B,A称为B的子集。\\ 集合相等\\ A=B \\Leftrightarrow A \\subset B且， A \\supset B\\ 真子集\\ A \\subset B,且 A \\neq B,则A就是B的真子集。A \\subsetneqq B $$ 空集 $$ \\emptyset $$ 并集 $$ A \\cup B = \\left{x \\middle| x \\in A\\ or\\ x \\in B \\right} $$ 交集 $$ A \\cap B = \\left{x \\middle| x \\in A\\ and\\ x \\in B \\right} $$ 差集 $$ A \\setminus B = \\left{x \\middle| x \\in A\\ and\\ x \\notin B \\right} $$ 余集或称补集 $$ \\overline{A} = A^C = \\left{x \\middle| x \\notin A \\right} $$ 交换律 $$ A \\cup B = B \\cup A\\ A \\cap B = B \\cap A\\ $$ 结合律 $$ (A \\cup B) \\cup C = A \\cup (B \\cup C)\\ (A \\cap B) \\cap C = A \\cap (B \\cap C)\\ $$ 分配律 $$ (A \\cup B) \\cap C = (A \\cap C) \\cup (B \\cap C)\\ (A \\cap B) \\cup C = (A \\cup C) \\cap (B \\cup C)\\ $$ 对偶率 $$ \\overline{(A \\cup B)} = \\overline{A} \\cap \\overline{B}\\ \\overline{(A \\cap B)} = \\overline{A} \\cup \\overline{B}\\ $$ ","date":"4994-40-48","objectID":"/%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/:1:3","tags":["集合与映射"],"title":"函数与极限","uri":"/%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/"},{"categories":["高等数学"],"content":"区间与邻域开区间 $$ (a,b)=\\left{x \\middle| a \u003c x \u003c b\\right} $$ 闭区间 $$ [a,b]=\\left{x \\middle| a \\leq x \\leq b\\right} $$ 邻域 $$ 以a为中心的一个开区间，就叫做a的邻域。\\ 不强调开区间的半径记做U(a)\\ 强调开区间的半径记做U(a, \\delta),点a的\\delta邻域\\ \\begin{aligned} U(a, \\delta) \u0026= \\left{x \\middle| x - \\delta \u003c x \u003c x + \\delta\\right}\\ \u0026=\\left{x\\middle| \\left|x - a\\right| \u003c \\delta \\right} \\end{aligned} $$ 点a的去心邻域 $$ \\mathring{U}(a, \\delta)=\\left{x \\middle| 0 \u003c \\left|x - a \\right| \u003c \\delta \\right} $$ ","date":"4994-40-48","objectID":"/%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/:1:4","tags":["集合与映射"],"title":"函数与极限","uri":"/%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/"},{"categories":["高等数学"],"content":"映射有两个非空的集合x和y，存在一个法则f，使得对任一x都有确定的y与之对应，则称f为x到y的一个映射。 记作 $$ f:x \\longrightarrow y\\ x:称为定义域，记作：Df\\ $$ $$ x \\in \\mathbb{X},f(x)=y\\ $$ y称为x的像，x称为y的一个原像。 所有的原像叫做值域Rf $$ Rf = \\left{ f(x) \\middle| x \\in \\mathbb{X} \\right} $$ 映射三要素 必须要有定义域Df、值域Rf、法则f 像唯一，原像不一定 满射，Rf=y 单射，原像也唯一 一一映射，单射+满射 ","date":"4994-40-48","objectID":"/%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/:2:0","tags":["集合与映射"],"title":"函数与极限","uri":"/%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/"},{"categories":["高等数学"],"content":"名词解释 算子：映射 泛函：y是R的一部分 变换：自己到自己的映射 函数：x属于R,y属于R ","date":"4994-40-48","objectID":"/%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/:2:1","tags":["集合与映射"],"title":"函数与极限","uri":"/%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/"},{"categories":["高等数学"],"content":"逆映射与复合映射单射，从像返回到原像 $$ f(x)=g,\\ f^-1(g)=x $$ ","date":"4994-40-48","objectID":"/%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/:2:2","tags":["集合与映射"],"title":"函数与极限","uri":"/%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/"},{"categories":["线性代数"],"content":"矩阵的初等行变换 两行互换 一行加上另一行的倍数 一行乘以一个非0数 ","date":"4994-40-48","objectID":"/%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/:0:1","tags":["线性方程组","矩阵"],"title":"解线性方程组","uri":"/%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/"},{"categories":["线性代数"],"content":"阶梯形矩阵 如果有全0行，那么全0行在最下方 所有行的主元的所在列随着行号增加而增加 阶梯的长度可以很长，但是高度必须为1。阶梯下全为0。 ","date":"4994-40-48","objectID":"/%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/:0:2","tags":["线性方程组","矩阵"],"title":"解线性方程组","uri":"/%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/"},{"categories":["线性代数"],"content":"简化行阶梯型矩阵 主元都是1，主元所在列的其余元素都为0. 自由未知量 主变量 一般解 ","date":"4994-40-48","objectID":"/%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/:0:3","tags":["线性方程组","矩阵"],"title":"解线性方程组","uri":"/%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/"},{"categories":["线性代数"],"content":"三种解当矩阵中出现0 = b时无解；非0行数 = 未知数个数时则有唯一解；非0行数 \u003c 未知数个数无穷解。 ","date":"4994-40-48","objectID":"/%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/:0:4","tags":["线性方程组","矩阵"],"title":"解线性方程组","uri":"/%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/"},{"categories":["线性代数"],"content":"行列式 性质1:矩阵与其转置矩阵的行列式相同 性质2:行列式某行乘以k倍 性质3:行列式某行是两个数之和 性质4:对换两行 性质5:两行相等 性质6:两行成比例 性质7:某行加上另外一行的倍数 ","date":"4994-40-48","objectID":"/%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/:1:0","tags":["线性方程组","矩阵"],"title":"解线性方程组","uri":"/%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/"},{"categories":["Unknow"],"content":"数学函数 函数 功能 abs(x) 返回输入参数的绝对值 acos(x) 反余切函数，输入参数范围为[-1,1]，返回[0,π ]区间的角度值 all(x) 如果输入参数均不为0，则返回ture；否则返回flase。\u0026\u0026运算 any(x) 输入参数只要有其中一个不为0，则返回true。||运算 asin(x) 反正弦函数,输入参数取值区间为[−1,1]，返回角度值范围为$$ \\begin{vmatrix} -\\frac{\\pi}{2}\u0026\\frac{\\pi}{2}\\end{vmatrix} $$ atan(x) 反正切函数，返回角度值范围为, atan2(y,x) 计算y/x 的反正切值。实际上和atan(x)函数功能完全一样，至少输入参数不同。atan(x) = atan2(x, float(1))。 ceil(x) 对输入参数向上取整。例如：ceil(float(1.3)) ，其返回值为2.0 clamp(x,a,b) 如果x 值小于a，则返回a；如果x 值大于b，返回b；否则，返回x。 cos(x) 返回弧度 x的余弦值。返回值范围为[−1,1] cosh(x) 双曲余弦（hyperbolic cosine）函数，计算x的双曲余弦值。 cross(A,B) 返回两个三元向量的叉积(cross product)。注意，输入参数必须是三元向量！ degrees(x) 输入参数为弧度值(radians)，函数将其转换为角度值(degrees) determinant(m) 计算矩阵的行列式因子。 dot(A,B) 返回A 和B 的点积(dot product)。参数A 和B可以是标量，也可以是向量（输入参数方面，点积和叉积函数有很大不同）。 exp(x) 计算ex的值，e= 2.71828182845904523536 exp2(x) 计算2x 的值 floor(x) 对输入参数向下取整。例如floor(float(1.3))返回的值为1.0；但是floor(float(-1.3))返回的值为-2.0。该函数与ceil(x)函数相对应。 fmod(x,y) 返回x/y 的余数。如果y 为0，结果不可预料。 frac(x) Returns the fractional portion of a scalar or each vector component frexp(x, outexp) 将浮点数x 分解为尾数和指数，即x = m* 2^exp，返回m，并将指数存入exp 中；如果x 为0，则尾数和指数都返回0 isfinite(x) 判断标量或者向量中的每个数据是否是有限数，如果是返回true；否则返回false;无限的或者非数据(not-a-number NaN) isinf(x) 判断标量或者向量中的每个数据是否是无限，如果是返回true；否则返回false; isnan(x) 判断标量或者向量中的每个数据是否是非数据(not-a-number NaN)，如果是返回true；否则返回false; ldexp(x, n) 计算x ∗2n的值 lerp(a, b, f) 计算(1− f )∗ a + b∗ f 或者a + f ∗(b − a)的值。即在下限a 和上限b 之间进行插值，f 表示权值。注意，如果a 和b 是向量，则权值f必须是标量或者等长的向量。 lit(NdotL,NdotH, m) N 表示法向量；L 表示入射光向量；H 表示半角向量；m 表示高光系数。函数计算环境光、散射光、镜面光的贡献，返回的4 元向量：X 位表示环境光的贡献，总是1.0；Y位代表散射光的贡献，如果N • L \u003c 0，则为 0；否则为N • LZ位代表镜面光的贡献，如果 N • L \u003c 0或者N • H \u003c 0，则位 0；否则为(N • H)m；W 位始终位1.0 log(x) 计算ln ( x)的值，x必须大于 0 log2(x) 计算( )2 log x 的值，x 必须大于0 log10(x) 计算( )10 log x 的值，x 必须大于0 max(a, b) 比较两个标量或等长向量元素，返回最大值。 min(a,b) 比较两个标量或等长向量元素，返回最小值。 modf(x, out ip) 在Cg Reference Manual 中没有查到 mul(M, N) 计算两个矩阵相乘，如果M 为AxB 阶矩阵，N 为BxC 阶矩阵，则返回AxC 阶矩阵。下面两个函数为其重载函数。 mul(M, v) 计算矩阵和向量相乘 mul(v, M) 计算向量和矩阵相乘 noise( x) 噪声函数，返回值始终在0，1 之间；对于同样的输入，始终返回相同的值（也就是说，并不是真正意义上的随机噪声）。 pow(x, y) x^y radians(x) 函数将角度值转换为弧度值 round(x) Round-to-nearest，或closest integer to x 即四舍五入。 rsqrt(x) X 的反平方根，x 必须大于0 saturate(x) 如果x 小于0，返回0；如果x 大于1，返回1；否则，返回x sign(x) 如果x 大于0，返回1；如果x 小于0，返回01；否则返回0。 sin(x) 输入参数为弧度，计算正弦值，返回值范围为[−1,1] sincos(float x,out s, out c) 该函数是同时计算x 的sin 值和cos 值，其中s=sin(x)，c=cos(x)。该函数用于“同时需要计算sin 值和cos 值的情况”，比分别运算要快很多! sinh(x) 计算双曲正弦（hyperbolic sine）值。 smoothstep(min,max, x) 值x 位于min、max 区间中。如果x=min，返回0；如果x=max，返回1；如果x 在两者之间，按照下列公式返回数据： 2*( min )3 3*( min )2 max min max min x − x − − + − − step(a, x) 如果x\u003ca，返回0；否则，返回1。 sqrt(x) 求x 的平方根， x ，x 必须大于0。 tan(x) 输入参数为弧度，计算正切值 tanh(x) 计算双曲正切值 transpose(M) M为矩阵，计算其转置矩阵 ","date":"4994-40-48","objectID":"/cgfunctions/:1:0","tags":["Unknow"],"title":"CGFunctions","uri":"/cgfunctions/"},{"categories":["Unity,SurfaceShader"],"content":" #pragma surface surfaceFunction lightModel [optionalparams] ","date":"4994-40-48","objectID":"/surfaceshader/:1:0","tags":["Surface"],"title":"SurfaceShader","uri":"/surfaceshader/"},{"categories":["Shader"],"content":" Shader \"path1/path2/ShaderName\" { Properties { _Int(\"Int\",int) = 0 _Float(\"Float\", float) = 0 _Range(\"Range\", Range(0,1)) = 0 _Color(\"Color\", Color) = (1,1,1,1) _Vector(\"Vector\", vector) = (1,1,1,1) _MainTex(\"Texture\", 2D) = \"\"{} _3D(\"3D Texture\", 3D) = \"\"{} _Cube(\"Cube Texture\", Cube) = \"\"{} } SubShader { Pass{ } } SubShader { } Fallback \"Diffuse\" } _Object2World == unity_ObjectToWorld UnityObjectToClipPos(vertex) UnityObjectToWorldNormal(normal) UnityWorldSpaceViewDir(worldPos) ","date":"4994-40-48","objectID":"/shaderlab/:0:0","tags":["Shader"],"title":"ShaderLab","uri":"/shaderlab/"},{"categories":["Shader"],"content":"语义 顶点输入语义 描述 POSITION 是顶点位置，通常为 float3 或 float4。 NORMAL 是顶点法线，通常为 float3。 TEXCOORD0…TEXCOORD3 是第n个 UV 坐标，通常为 float2、float3 或 float4。 TANGENT 是切线矢量（用于法线贴图），通常为 float4。 COLOR 是每顶点颜色，通常为 float4。 uint vid : SV_VertexID（顶点参数） 顶点着色器可以接收具有“顶点编号”（为无符号整数）的变量。需要添加 #pragma target 3.5 编译指令。 顶点输出语义 描述 SV_POSITION 顶点的最终裁剪空间位置 float4 类型 TEXCOORD0~n 用于指示任意高精度数据，如纹理坐标和位置。 COLOR0~n 用于低精度 0 到 1 范围的数据。 只能当片元输入参数 描述 UNITY_VPOS_TYPE screenPos : VPOS 像素的位置。 需要#pragma target 3.0 编译指令。 VFACE 片元着色器可以接收一种指示渲染表面是面向摄像机还是背对摄像机的变量。VFACE 语义输入变量将包含表示正面三角形的正值，以及表示背面三角形的负值。需要#pragma target 3.0 编译指令。 片元输出 描述 SV_Target 片元（像素）着色器会输出颜色 SV_TargetN 这些是着色器写入的附加颜色。这在一次渲染到多个渲染目标（称为“多渲染目标”渲染技术，简称 MRT）时使用。SV_Target0 等同于 SV_Target。 SV_Depth 像素着色器深度输出 ","date":"4994-40-48","objectID":"/shaderlab/:1:0","tags":["Shader"],"title":"ShaderLab","uri":"/shaderlab/"},{"categories":["Unity"],"content":"Editor MenuItem 用于修饰函数，在编辑器中添加菜单项（脚本需要放在Editor目录） [MenuItem(string itemName, bool isValidateFunction, int priority)] public static void Test(){ } CreateAssetMenu 用于创建ScriptObject资源文件菜单（无需放在Editor目录） Header HideInInspector TextArea CustomEditor OnOpenAsset SerializeField ","date":"1991-10-18","objectID":"/unity%E7%89%B9%E6%80%A7/:1:0","tags":["Unity"],"title":"Unity特性","uri":"/unity%E7%89%B9%E6%80%A7/"},{"categories":["Unity"],"content":"约束 RequireComponent(typeof(OneComponent)) HideInInspector ","date":"1991-10-18","objectID":"/unity%E7%89%B9%E6%80%A7/:2:0","tags":["Unity"],"title":"Unity特性","uri":"/unity%E7%89%B9%E6%80%A7/"},{"categories":["Unity"],"content":" Conditional ","date":"1991-10-18","objectID":"/unity%E7%89%B9%E6%80%A7/:3:0","tags":["Unity"],"title":"Unity特性","uri":"/unity%E7%89%B9%E6%80%A7/"},{"categories":["cpp"],"content":"普通常量定义const常量时必须对其初始化，且初始化后不能修改其值；常量与变量可以相互赋值。 int n1 = 10; const int n2 = n1; n1 = n2; ","date":"129912-120-128","objectID":"/const/:1:0","tags":null,"title":"c++ const使用","uri":"/const/"},{"categories":["cpp"],"content":"const与引用初始化引用或参数传递给引用的各种情况 引用 变量 常量 表达式 字面值 普通引用（int\u0026） true false false false 常引用（const int\u0026） true true true true int n1 = 10; const int n2 = 20; int\u0026 r1 = n1; //普通引用只能引用变量 // 常量引用可以引用变量、常量、表达式、字面值 const int\u0026 r2 = n1; const int\u0026 r3 = n2; const int\u0026 r4 = 3 * 4; const int\u0026 r5 = 10; ","date":"129912-120-128","objectID":"/const/:2:0","tags":null,"title":"c++ const使用","uri":"/const/"},{"categories":["cpp"],"content":"const与指针 指针的各种赋值情况 指针 变量 常量 普通指针（int*） true false 常量指针（const int*） true true 常量指针与指针常量的区别 常量指针const在号的左边，表示指针地址对应的值不可改变；指针常量const在号的右边，表示指针地址不可改变。 当指针、typedef、const结合使用时，稍有不同。 typedef char * StringPtr; const StringPtr value = \"\"; // 等价于 char * const value = \"\"; ","date":"129912-120-128","objectID":"/const/:3:0","tags":null,"title":"c++ const使用","uri":"/const/"},{"categories":["cpp"],"content":"const与函数参数 普通函数参数（指针和引用除外）不能通过加减const实现函数重载。 ","date":"129912-120-128","objectID":"/const/:4:0","tags":null,"title":"c++ const使用","uri":"/const/"},{"categories":["cpp"],"content":"const与类 const成员变量：只能在构造函数初始化列表中初始化（只是在对象中是不可变的）。整个类中不变得使用enum const成员函数：函数中不能修改成员变量，也不能调用普通成员函数，却可以被普通成员函数调用，可以和普通成员函数实现重载。 ","date":"129912-120-128","objectID":"/const/:5:0","tags":null,"title":"c++ const使用","uri":"/const/"},{"categories":["cpp"],"content":"用法1如果某个const变量需要在多个文件中共享，又不能在头文件中初始化，这个时候可以在头文件中用extern声明，在cpp中初始化const量 ","date":"129912-120-128","objectID":"/const/:6:0","tags":null,"title":"c++ const使用","uri":"/const/"},{"categories":["cpp"],"content":"const_castconst_cast只能移除指针或引用的const或volatile限定符 dynamic_cast、static_cast、reinterpret_cast ","date":"129912-120-128","objectID":"/const/:7:0","tags":null,"title":"c++ const使用","uri":"/const/"},{"categories":["Lua"],"content":"C调用Lua首先读取lua原文件，然后将要调用的lua函数压入栈中，之后再将函数参数依次压入栈中，最后使用函数lua_pcall调用lua函数，另外lua函数返回值会被压入栈中。 ","date":"119911-110-118","objectID":"/lua%E4%B8%8Ec%E4%BA%A4%E4%BA%92/:1:0","tags":["Lua C++"],"title":"Lua与C/C++交互","uri":"/lua%E4%B8%8Ec%E4%BA%A4%E4%BA%92/"},{"categories":["Lua"],"content":"定义Lua local Test = {} function Test:waitForCppCall(name, age) print(name) print(age) return string.format(\"Hello I'm %s %d years old.\",name,age) end return Test ","date":"119911-110-118","objectID":"/lua%E4%B8%8Ec%E4%BA%A4%E4%BA%92/:1:1","tags":["Lua C++"],"title":"Lua与C/C++交互","uri":"/lua%E4%B8%8Ec%E4%BA%A4%E4%BA%92/"},{"categories":["Lua"],"content":"调用Lua代码 auto L = luaL_newstate(); luaL_openlibs(L); // dofile会将代码块中的返回值压入栈 luaL_dofile(L,\"../lua/main.lua\"); // 堆栈情况{table(Test)} lua_getfield(L,1,\"waitForCppCall\"); // 堆栈情况{table(Test),waitForCppCall()} // lua的函数用`：`形式定义的，这里还需要将table传入 lua_pushvalue(L,1); // 堆栈情况{table(Test),waitForCppCall(),table(Test)} lua_pushstring(L,\"Sean\"); // 堆栈情况{table(Test),waitForCppCall(),table(Test), \"Sean\"} lua_pushnumber(L,20); // 堆栈情况{table(Test),waitForCppCall(),table(Test), \"Sean\", 20} lua_pcall(L,3,1,0); // 堆栈情况{table(Test),[函数返回值1,函数返回值2,...]} lua_close(L); ","date":"119911-110-118","objectID":"/lua%E4%B8%8Ec%E4%BA%A4%E4%BA%92/:1:2","tags":["Lua C++"],"title":"Lua与C/C++交互","uri":"/lua%E4%B8%8Ec%E4%BA%A4%E4%BA%92/"},{"categories":["Lua"],"content":"Lua调用C","date":"119911-110-118","objectID":"/lua%E4%B8%8Ec%E4%BA%A4%E4%BA%92/:2:0","tags":["Lua C++"],"title":"Lua与C/C++交互","uri":"/lua%E4%B8%8Ec%E4%BA%A4%E4%BA%92/"},{"categories":["Lua"],"content":"定义Lua可调用的函数lua调用的c/c++函数必须满足 static int add(lua_State *L){ int n = lua_gettop(L); cout \u003c\u003c \"参数个数：\" \u003c\u003c n \u003c\u003c endl; double sum = 0; for (size_t i = 1; i \u003c= n; i++) { double d = lua_tonumber(L, i); cout \u003c\u003c \"第\" \u003c\u003c i \u003c\u003c \"个参数：\" \u003c\u003c d \u003c\u003c endl; sum += d; } lua_pushnumber(L, sum); lua_pushstring(L, \"我就测试一下第二返回值。\"); return 2; } ","date":"119911-110-118","objectID":"/lua%E4%B8%8Ec%E4%BA%A4%E4%BA%92/:2:1","tags":["Lua C++"],"title":"Lua与C/C++交互","uri":"/lua%E4%B8%8Ec%E4%BA%A4%E4%BA%92/"},{"categories":["Lua"],"content":"注册函数到lua解释器中 static const struct luaL_Reg reg[] = { {\"add\", add}, {NULL, NULL}, }; LUALIB_API int luaopen_fun(lua_State *L){ luaL_newlib(L, reg); return 1; } luaL_requiref(L,\"ModuleName\", luaopen_fun, 1); ","date":"119911-110-118","objectID":"/lua%E4%B8%8Ec%E4%BA%A4%E4%BA%92/:2:2","tags":["Lua C++"],"title":"Lua与C/C++交互","uri":"/lua%E4%B8%8Ec%E4%BA%A4%E4%BA%92/"},{"categories":["Lua"],"content":"调用C/C++函数 print(ModuleName.add(1,2,3,6,5,4)) ","date":"119911-110-118","objectID":"/lua%E4%B8%8Ec%E4%BA%A4%E4%BA%92/:2:3","tags":["Lua C++"],"title":"Lua与C/C++交互","uri":"/lua%E4%B8%8Ec%E4%BA%A4%E4%BA%92/"},{"categories":["Lua"],"content":"类型对应关系 数据类型 C Lua nil 无 {value=0, tt = t_nil} boolean int 非0, 0 {value=非0/0， tt = t_boolean} number int/float等 {value=1.5, tt = t_number} lightuserdata void*, int*, 各种*point {value=point, tt = t_lightuserdata} string char str[] {value=gco, tt = t_string} gco=TString obj table 无 {value=gco, tt = t_table} gco=Table obj userdata 无 {value=gco, tt = t_udata} gco=Udata obj closure 无 {value=gco, tt = t_function} gco=Closure obj ","date":"119911-110-118","objectID":"/lua%E4%B8%8Ec%E4%BA%A4%E4%BA%92/:3:0","tags":["Lua C++"],"title":"Lua与C/C++交互","uri":"/lua%E4%B8%8Ec%E4%BA%A4%E4%BA%92/"},{"categories":["Lua"],"content":"常用函数 lua_gettop(lua_State *L) 返回栈顶索引（即栈长度） lua_settop (lua_State *L, int idx) 将栈顶设置为一个指定的位置，即修改栈中元素的数量。如果值比原栈顶高，则高的部分nil补足，如果值比原栈低，则原栈高出的部分舍弃。所以可以用lua_settop(L, 0)来清空栈。 lua_close lua_register lua_getglobal(lua_State *L, const char *name) 把全局变量 name 里的值压栈，然后由Lua去寻找变量name的值，并将变量name的值返回栈顶（替换name） lua_getfield() lua_setfield() 获取或者设置表中的值 lua_pcall(lua_State *L, int nargs, int nresults, int msgh) 依次将函数参数和函数从栈中弹出，然后调用函数，并把最后函数的返回值压入栈中。 ","date":"119911-110-118","objectID":"/lua%E4%B8%8Ec%E4%BA%A4%E4%BA%92/:4:0","tags":["Lua C++"],"title":"Lua与C/C++交互","uri":"/lua%E4%B8%8Ec%E4%BA%A4%E4%BA%92/"},{"categories":["Lua"],"content":"luaL_*辅助库+ luaL_newstate + luaL_openlibs + luaL_dofile + lua_push* + lua_to* + lua_createtable ","date":"119911-110-118","objectID":"/lua%E4%B8%8Ec%E4%BA%A4%E4%BA%92/:5:0","tags":["Lua C++"],"title":"Lua与C/C++交互","uri":"/lua%E4%B8%8Ec%E4%BA%A4%E4%BA%92/"},{"categories":["Lua"],"content":"模块 load(\"\" || function [, chunkname , mode , env]) 功能： 以字符串为函数体构建一个function(…)代码块编译并返回，如果第一个参数不是字符串而是function，则load会不断的调用function来获得字符串，直至function返回nil。 返回值：function(…) 错误处理：不会引发错误，返回值nil,error 因为需要额外编译（全局环境下）所以比直接定义function要慢。 loadfile([filename [, mode [, env]]]) 功能：从文件加载、编译代码，返回代码块(不调用函数，函数可复用)。 返回值：function(…) 错误处理：不会引发错误，返回值nil,error loadstring() 功能：同loadfile,只是从字符串中加载代码。 返回值：function(…) 错误处理：不会引发错误，返回值为nil,error dofile(filename) 功能：加载、编译、执行代码块（每次调用都会执行） 返回值：代码块的返回值,无返回值即nil 错误处理：引发错误 function dofile (filename) local f = assert(loadfile(filename)) return f() end require(modname) 功能：搜索目录加载、编译、执行代码块（多次调用只执行一次） 返回值：代码块的返回值,无返回值即true 错误处理：引发错误 ","date":"109910-100-108","objectID":"/lua-%E5%9F%BA%E7%A1%80%E5%87%BD%E6%95%B0/:1:0","tags":["Lua"],"title":"Lua 基础函数","uri":"/lua-%E5%9F%BA%E7%A1%80%E5%87%BD%E6%95%B0/"},{"categories":["Lua"],"content":"元表 getmetatable setmetatable 如果table中存在__metatable字段，函数调用失败。 编号 元方法 符号 1 __add +（加） 2 __sub -（减） 3 __mul *（乘） 4 __div /（除） 5 __mod %（取余） 6 __pow ^ （次方） 7 __unm - （取负） 8 __idiv // （向下取整除法） 9 __band \u0026 （按位与） 10 __bor | （按位或） 11 __bxor ~ （按位异或） 12 __bnot ~ （按位非） 13 __shl « （左移） 14 __shr » （右移） 15 __concat .. （连接） 16 __len # （取长度） 17 __eq == （等于） 18 __lt \u003c （小于） 19 __le \u003c= （小于等于） 20 __index(tab, key) 索引 table[key] 21 __newindex(tab, key, value) 索引赋值 table[key] = value 22 __call(selfTab, newTab) 函数调用操作 func(args) 23 __tostring(tab) 修改表的输出行为 ","date":"109910-100-108","objectID":"/lua-%E5%9F%BA%E7%A1%80%E5%87%BD%E6%95%B0/:2:0","tags":["Lua"],"title":"Lua 基础函数","uri":"/lua-%E5%9F%BA%E7%A1%80%E5%87%BD%E6%95%B0/"},{"categories":["Lua"],"content":"不触发元方法 rawequal rawlen rawget rawset ","date":"109910-100-108","objectID":"/lua-%E5%9F%BA%E7%A1%80%E5%87%BD%E6%95%B0/:3:0","tags":["Lua"],"title":"Lua 基础函数","uri":"/lua-%E5%9F%BA%E7%A1%80%E5%87%BD%E6%95%B0/"},{"categories":["Lua"],"content":"类型转换 tonumber tostring pcall xpcall ","date":"109910-100-108","objectID":"/lua-%E5%9F%BA%E7%A1%80%E5%87%BD%E6%95%B0/:4:0","tags":["Lua"],"title":"Lua 基础函数","uri":"/lua-%E5%9F%BA%E7%A1%80%E5%87%BD%E6%95%B0/"},{"categories":["Lua"],"content":"循环迭代 next (table [, key]) 返回table中指定key的下一个key和value，key为nil时将返回初始key及其value，传入最后一个key时next会返回nil（可以用来判断表是否为空）。 pairs pairs可以遍历表中全部key，value ipairs key从数字1开始遍历，每次key累加1，当key对应的value为nil时终止遍历。如果非数字key或1开始key~=1或key数值不连续都不能完全遍历table。 Note: #和table.getn(t)会在索引中断的地方停止计数，map形式的table不能通过这种方式获得长度 ","date":"109910-100-108","objectID":"/lua-%E5%9F%BA%E7%A1%80%E5%87%BD%E6%95%B0/:5:0","tags":["Lua"],"title":"Lua 基础函数","uri":"/lua-%E5%9F%BA%E7%A1%80%E5%87%BD%E6%95%B0/"},{"categories":["Lua"],"content":"其他 type error print select(number | “#”, …) assert(v: any, message: any) collectgarbage ","date":"109910-100-108","objectID":"/lua-%E5%9F%BA%E7%A1%80%E5%87%BD%E6%95%B0/:6:0","tags":["Lua"],"title":"Lua 基础函数","uri":"/lua-%E5%9F%BA%E7%A1%80%E5%87%BD%E6%95%B0/"},{"categories":["Lua"],"content":"闭包lua中两个嵌套函数，内部函数可以访问到外部函数中定义的局部变量（也叫upvalues），其中内部函数和那些被内部函数使用了的外部局部变量叫做闭包。 ","date":"109910-100-108","objectID":"/lua-%E5%9F%BA%E7%A1%80%E5%87%BD%E6%95%B0/:7:0","tags":["Lua"],"title":"Lua 基础函数","uri":"/lua-%E5%9F%BA%E7%A1%80%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"端口占用lsof通过list open file命令可以查看到当前打开文件，在Unix中所有事物都是以文件形式存在，包括网络连接及硬件设备。 lsof -i:80 -i表示网络链接 :80指明端口号 该命令会同时列出PID，方便kill killkill命令用来终止一个进程。 kill 1234 1234 表示进程PID号 先用lsof查出占用端口号的进程，然后再用kill终止它。 ","date":"1991-10-18","objectID":"/macosxcommand/:0:1","tags":["Mac","端口占用"],"title":"Mac OSX 实用命令","uri":"/macosxcommand/"},{"categories":null,"content":"title: class内存布局 class的内存布局和这几个有关系virtual函数、继承、多继承、virtual继承 ","date":"1991-10-18","objectID":"/class%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/:0:0","tags":null,"title":"","uri":"/class%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/"},{"categories":null,"content":"虚函数类中自动添加一个虚函数指针，指向虚函数表，表中记录所有的虚函数地址。 ","date":"1991-10-18","objectID":"/class%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/:1:0","tags":null,"title":"","uri":"/class%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/"},{"categories":null,"content":"继承+虚函数子类会继承父类的虚函数指针，被子类重写的虚函数会覆盖父类的虚函数地址，没有被重写的仍然沿用父类虚函数，新增的虚函数则会按照定义的顺序依次添加到虚函数表中。 ","date":"1991-10-18","objectID":"/class%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/:2:0","tags":null,"title":"","uri":"/class%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/"},{"categories":null,"content":"多继承+虚函数子类会从多个父类继承它们的虚函数指针，子类重写的的虚函数会分别覆盖各虚函数表中的函数地址（如果父类中存在同名的函数都会被重写）。另外子类新增的虚函数会添加到第一个虚函数表中。 ","date":"1991-10-18","objectID":"/class%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/:3:0","tags":null,"title":"","uri":"/class%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/"},{"categories":null,"content":"虚继承+虚函数","date":"1991-10-18","objectID":"/class%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/:4:0","tags":null,"title":"","uri":"/class%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/"},{"categories":null,"content":"多虚继承+虚函数","date":"1991-10-18","objectID":"/class%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/:5:0","tags":null,"title":"","uri":"/class%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/"},{"categories":null,"content":"auto使用容器迭代器遍历的时候特别方便，不需要写集合的嵌套类型 ","date":"1991-10-18","objectID":"/cpp11/:1:0","tags":null,"title":"","uri":"/cpp11/"},{"categories":null,"content":"容器的列表初始化","date":"1991-10-18","objectID":"/cpp11/:2:0","tags":null,"title":"","uri":"/cpp11/"},{"categories":null,"content":"nullptr #ifdef __cplusplus #define NULL 0 #else #define NULL ((void *)0) #endif c中void*可以隐式转换成其他类型的指针，但是在c++中不能隐式转换 在C++中，使用0来做为空指针会比使用NULL来做空指针会让你更加警觉。 ","date":"1991-10-18","objectID":"/cpp11/:3:0","tags":null,"title":"","uri":"/cpp11/"},{"categories":null,"content":"thread","date":"1991-10-18","objectID":"/cpp11/:4:0","tags":null,"title":"","uri":"/cpp11/"},{"categories":null,"content":"sharedptr","date":"1991-10-18","objectID":"/cpp11/:5:0","tags":null,"title":"","uri":"/cpp11/"},{"categories":null,"content":"右值引用","date":"1991-10-18","objectID":"/cpp11/:6:0","tags":null,"title":"","uri":"/cpp11/"},{"categories":null,"content":"lambda","date":"1991-10-18","objectID":"/cpp11/:7:0","tags":null,"title":"","uri":"/cpp11/"},{"categories":null,"content":"title: memmove 和 memcpy的区别 memcpy(void *_Dst, const void *_Src, int _Val, size_t _Size); memmove(void *_Dst, const void *_Src, size_t _MaxCount) 内存重叠的情况下memcpy可能会出错，也可能不会出错 ","date":"1991-10-18","objectID":"/memmovememcpy/:0:0","tags":null,"title":"","uri":"/memmovememcpy/"},{"categories":null,"content":"title: 智能指针","date":"1991-10-18","objectID":"/smartpointer/:1:0","tags":null,"title":"","uri":"/smartpointer/"},{"categories":null,"content":"std::auto_ptr p(new Class())","date":"1991-10-18","objectID":"/smartpointer/:2:0","tags":null,"title":"","uri":"/smartpointer/"},{"categories":null,"content":"缺点 当函数参数时不能引用计数加1 不能和操作符new[] 一起使用 不能和标准容器一起使用 ","date":"1991-10-18","objectID":"/smartpointer/:2:1","tags":null,"title":"","uri":"/smartpointer/"},{"categories":null,"content":"std::shared_ptr","date":"1991-10-18","objectID":"/smartpointer/:3:0","tags":null,"title":"","uri":"/smartpointer/"},{"categories":null,"content":"title: 矩阵 行数=列数 叫做方阵 ","date":"1991-10-18","objectID":"/matrix/:0:0","tags":null,"title":"","uri":"/matrix/"},{"categories":null,"content":"矩阵运算","date":"1991-10-18","objectID":"/matrix/:1:0","tags":null,"title":"","uri":"/matrix/"},{"categories":null,"content":"加法A + B 各对应元素相加 ","date":"1991-10-18","objectID":"/matrix/:1:1","tags":null,"title":"","uri":"/matrix/"},{"categories":null,"content":"矩阵数量乘法k · A ","date":"1991-10-18","objectID":"/matrix/:1:2","tags":null,"title":"","uri":"/matrix/"},{"categories":null,"content":"矩阵幂运算只有方阵才可以幂运算 ","date":"1991-10-18","objectID":"/matrix/:1:3","tags":null,"title":"","uri":"/matrix/"},{"categories":null,"content":"矩阵转置行变成列，列变成行 矩阵转置的性质 $$ \\left(A^T\\right)^T=A $$ $$ \\left(A+B\\right)^T=A^T+B^T $$ $$ \\left(k\\cdot A\\right)^T=k\\cdot A^T $$ $$ \\left(A\\cdot B\\right)^T=B^T\\cdot A^T $$ $$ \\left(A\\cdot B\\right)^{-1}=B^{-1}\\cdot A^{-1} $$ $$ \\left(A^T\\right)^{-1}=\\left(A^{-1}\\right)^T $$ ","date":"1991-10-18","objectID":"/matrix/:1:4","tags":null,"title":"","uri":"/matrix/"},{"categories":null,"content":"翻转矩阵","date":"1991-10-18","objectID":"/matrix/:2:0","tags":null,"title":"","uri":"/matrix/"},{"categories":null,"content":"错切矩阵","date":"1991-10-18","objectID":"/matrix/:3:0","tags":null,"title":"","uri":"/matrix/"},{"categories":null,"content":"旋转矩阵 视频5-2两角差的余弦公式 $$ \\cos\\left(a-b\\right)=\\cos\\left(a\\right)\\cos\\left(b\\right)+\\sin\\left(a\\right)\\sin\\left(b\\right) $$ 两角差正弦公式 $$ \\sin\\left(a-b\\right)=\\sin\\left(a\\right)\\cos\\left(b\\right)-\\cos\\left(a\\right)\\sin\\left(b\\right) $$ ","date":"1991-10-18","objectID":"/matrix/:4:0","tags":null,"title":"","uri":"/matrix/"},{"categories":null,"content":"单位矩阵单位矩阵是一个方阵 $$ I_n=\\begin{bmatrix}1\u00260\u0026\\cdots\u00260\\0\u00261\u0026\\cdots\u00260\\\\cdots\u0026\\cdots\u0026\\cdots\u0026\\cdots\\0\u00260\u0026\\cdots\u00261\\end{bmatrix} $$ 左上角到右下角叫做主对角线 单位矩阵满足乘法的交换律 ","date":"1991-10-18","objectID":"/matrix/:5:0","tags":null,"title":"","uri":"/matrix/"},{"categories":null,"content":"矩阵的逆$$ 当满足AB=BA=I时，则B是A的逆矩阵，记做：B=A^{-1} $$ 可逆矩阵，或者叫非奇异矩阵（必定是方阵） 不可逆矩阵，或者叫奇异矩阵 左逆矩阵和右逆矩阵 如果同时存在左逆矩阵又存在右逆矩阵，那么这两个矩阵必定是相等的且是方阵 如何判断以及计算逆矩阵？ $$ A^0=I;,A^{-1}=A的逆矩阵;,A^{-2}={(A^{-1})}^2 $$ ","date":"1991-10-18","objectID":"/matrix/:6:0","tags":null,"title":"","uri":"/matrix/"},{"categories":null,"content":"矩阵的四个视角 二位数据 系统 变换 空间 ","date":"1991-10-18","objectID":"/matrix/:7:0","tags":null,"title":"","uri":"/matrix/"},{"categories":null,"content":"高斯消元法 6.2 矩阵的某行乘以一个常数 矩阵的一行加减另外一行 交互矩阵的两行 ","date":"1991-10-18","objectID":"/matrix/:8:0","tags":null,"title":"","uri":"/matrix/"},{"categories":null,"content":"高斯约旦消元法 前向过程 后向过程 $$ \\begin{pmatrix}1\u00260\u00260\u0026\\left|2\\right.\\0\u00261\u00260\u0026\\left|-3\\right.\\0\u00260\u00261\u0026\\left|-4\\right.\\end{pmatrix} 唯一解 \\begin{pmatrix}1\u00260\u00262\u0026\\left|3\\right.\\0\u00261\u0026-3\u0026\\left|10\\right.\\0\u00260\u00260\u0026\\left|5\\right.\\end{pmatrix} 无解 \\begin{pmatrix}1\u00260\u00262\u0026\\left|0\\right.\\0\u00261\u0026-3\u0026\\left|0\\right.\\0\u00260\u00260\u0026\\left|0\\right.\\end{pmatrix} 无数解 $$ ","date":"1991-10-18","objectID":"/matrix/:9:0","tags":null,"title":"","uri":"/matrix/"},{"categories":null,"content":"方程个数与未知数个数的关系 方程个数\u003c未知数 方程个数=未知数 方程个数\u003e未知数 无解 无解 无解 唯一解 唯一解 无数解 无数解 无数解 ","date":"1991-10-18","objectID":"/matrix/:10:0","tags":null,"title":"","uri":"/matrix/"},{"categories":null,"content":"初等矩阵(E) 矩阵的某行乘以一个常数 矩阵的行交换 矩阵的某行加减某行的的若干倍 ","date":"1991-10-18","objectID":"/matrix/:11:0","tags":null,"title":"","uri":"/matrix/"},{"categories":null,"content":"特征值\u0026特征向量某些向量经过矩阵变换并不会改变向量的方向，只按照一定的倍数缩放向量的长度，那么其中的倍数和向量 ","date":"1991-10-18","objectID":"/matrix/:12:0","tags":null,"title":"","uri":"/matrix/"},{"categories":null,"content":"数学公式在线生成工具http://www.wiris.com/editor/demo/en/developers ","date":"1991-10-18","objectID":"/matrix/:12:1","tags":null,"title":"","uri":"/matrix/"},{"categories":null,"content":"title: 三角形 ","date":"1991-10-18","objectID":"/triangle/:0:0","tags":null,"title":"","uri":"/triangle/"},{"categories":null,"content":"n边形的内角和(n-1)*180 ","date":"1991-10-18","objectID":"/triangle/:1:0","tags":null,"title":"","uri":"/triangle/"},{"categories":null,"content":"共同角度的三角形，斜边比底边相同","date":"1991-10-18","objectID":"/triangle/:1:1","tags":null,"title":"","uri":"/triangle/"},{"categories":null,"content":"三角函数就是直角三角形的边长比例","date":"1991-10-18","objectID":"/triangle/:1:2","tags":null,"title":"","uri":"/triangle/"},{"categories":null,"content":"三角函数sin(A) 对比斜 cosec(A) cos(A) 邻比斜 sec(A) tan(A) 对比邻 cot(A) ","date":"1991-10-18","objectID":"/triangle/:2:0","tags":null,"title":"","uri":"/triangle/"},{"categories":null,"content":"title: 判断三角形顶点顺序 tag:p1 = (0,0） p2 = (4,0) p3 = (3,3) 顺序 p1,p2,p3 v1 = p2 - p1 = (4,0) v2 = p3 - p1 = (3,3) v1 x v2 = 4*3 - 0*3 = 12 顺序p1,p3,p2 v1 = p3 - p1 = (3,3) v2 = p2 - p1 = (4,0) v2 x v1 = 3*0 - 3*4 = -12 ","date":"1991-10-18","objectID":"/triangleorder/:1:0","tags":null,"title":"","uri":"/triangleorder/"},{"categories":null,"content":"title: 向量 date: 2020-10-31 12:20:53 tags: Vector categories: Vector向量：一串有序的数字，可以看成是一段有向的险段，也可以看成是空间中的一个点。 ","date":"1991-10-18","objectID":"/vector/:1:0","tags":null,"title":"","uri":"/vector/"},{"categories":null,"content":"向量的两个视角 有向的线段 空间中的一个点 ","date":"1991-10-18","objectID":"/vector/:1:1","tags":null,"title":"","uri":"/vector/"},{"categories":null,"content":"考虑起始点和不考虑起始点的向量表示方法$$ \\overset\\rightharpoonup A\\\\mathrm{向量}A\\ \\overset\\rightharpoonup{OA}\\\\mathrm{从原点}O到A $$ ","date":"1991-10-18","objectID":"/vector/:1:2","tags":null,"title":"","uri":"/vector/"},{"categories":null,"content":"行向量和列向量$$ \\begin{pmatrix}3\u00264\\end{pmatrix}\\行向量\\ \\begin{pmatrix}3\\4\\end{pmatrix}\\列向量\\ \\begin{pmatrix}3\u00264\\end{pmatrix}^T\\书本列向量表示方式\\ $$ ","date":"1991-10-18","objectID":"/vector/:1:3","tags":null,"title":"","uri":"/vector/"},{"categories":null,"content":"向量的运算u + v k · u ","date":"1991-10-18","objectID":"/vector/:1:4","tags":null,"title":"","uri":"/vector/"},{"categories":null,"content":"向量运算的基本性质$$ \\overset\\rightharpoonup u+\\overset\\rightharpoonup v=\\overset\\rightharpoonup v+\\overset\\rightharpoonup u\\ \\left(k+c\\right)\\overset\\rightharpoonup u=k\\overset\\rightharpoonup u+{c\\overset\\rightharpoonup u}\\ \\left(\\overset\\rightharpoonup u+\\overset\\rightharpoonup v\\right)+\\overset\\rightharpoonup w=\\overset\\rightharpoonup u+\\left(\\overset\\rightharpoonup v+\\overset\\rightharpoonup w\\right)\\ \\left(kc\\right)\\overset\\rightharpoonup u=k\\left(c\\overset\\rightharpoonup u\\right)\\ k\\left(\\overset\\rightharpoonup u+\\overset\\rightharpoonup v\\right)=k\\overset\\rightharpoonup u+k\\overset\\rightharpoonup v\\ 1\\overset\\rightharpoonup u=\\overset\\rightharpoonup u\\ $$ ","date":"1991-10-18","objectID":"/vector/:1:5","tags":null,"title":"","uri":"/vector/"},{"categories":null,"content":"向量的模","date":"1991-10-18","objectID":"/vector/:1:6","tags":null,"title":"","uri":"/vector/"},{"categories":null,"content":"单位向量符号表示 标准单位向量：只有1个1和n个0组成的向量 e1（1，0） e2（0，1） ","date":"1991-10-18","objectID":"/vector/:1:7","tags":null,"title":"","uri":"/vector/"},{"categories":null,"content":"余弦定理","date":"1991-10-18","objectID":"/vector/:1:8","tags":null,"title":"","uri":"/vector/"},{"categories":null,"content":"点乘点乘的两个公式 0 垂直 0 锐角 \u003c 0 钝角 ","date":"1991-10-18","objectID":"/vector/:1:9","tags":null,"title":"","uri":"/vector/"},{"categories":null,"content":"Data CharacterStatsDefinition AttackDefinition Weapon 武器攻击 weaponPreb Spell 魔法攻击 Aoe ItemDefinition itemMaterial itemIcon itemSpawnObject weaponSlotObject ","date":"1991-10-18","objectID":"/system/:1:0","tags":null,"title":"","uri":"/system/"},{"categories":null,"content":"Monobehaviour ItemPickUp ItemDefinition CharacterStats UseItem() StoreItemInInventory() CharacterInventory itemsInInventory StoreItem() TryPickUp() AddItemToInv() SpawnItem List ids CreateSpawn() return ItemDefinition.itemSpawnObject CharacterStats characterWeaponSlot 战利品 ItemDefinition ItemPickUp SpawnItem 背包 InventoryEntry ItemPickUp stackSize inventorySolt iconSprite ChatacterInventory 战斗 AttackDefinition Weapon Spell AOE Attack IAttackable AttackedScrollingText AttackedTakeDamage AttackedForce 统计 ChatacterStatsDefinition ChatacterStats ","date":"1991-10-18","objectID":"/system/:2:0","tags":null,"title":"","uri":"/system/"},{"categories":null,"content":"TCP参数 ReceiveBufferSize SendBufferSize NoDelay TTL（time to live） ReuseAddress LingerState ","date":"1991-10-18","objectID":"/tcpip/:0:0","tags":null,"title":"","uri":"/tcpip/"},{"categories":null,"content":"三块存储区域 栈、托管堆、非托管堆","date":"1991-10-18","objectID":"/gc/:1:0","tags":null,"title":"垃圾回收","uri":"/gc/"},{"categories":null,"content":"托管堆的创建实现了Finalize方法的类，创建其对象时会将对象的指针添加到finalization链表中，当对象成为垃圾时GC会将对象指针从finalization中删除并添加到freachable队列中，之后会启动一个高优先级线程，用来遍历freachable队列并调用每个对象的Finalize方法，至此只是销毁了非托管资源，托管资源需要等到下一次GC工作时才能被销毁。 代龄 NextObjPtr root 内存压缩 IDispose using ","date":"1991-10-18","objectID":"/gc/:2:0","tags":null,"title":"垃圾回收","uri":"/gc/"},{"categories":null,"content":" const 变量 引用 指针 函数参数 成员函数 成员变量 引用与指针的区别 引用必须初始化，且初始化后不能再引用其他 引用不能引用空位置 inline的优劣 final override The rule ofthree是什么？为什么这么做？ 析构函数，拷贝构造函数，赋值运算符尽可能一起声明。如果你只定义一个，编译器会帮助你定义另外两个，而编译器定义的版本也许不是你想要的 C++11的新特性 auto vector以及其他容器的列表初始化 nullptr thread，不需要再使用其他的库来写多线程了 智能指针shareptr，一定程度上解决内存泄露问题 右值引用，减少拷贝开销 lambda Delete数组的一部分会发生什么？为什么出现异常？ 系统是如何知道指针越界的？ C++编译器有哪些常见的优化？听说过RVO（NRVO）么？ 听说过mangling么？ 成员函数指针了解么？可以转换为Void*么？为什么？ 描述一下C/C++代码的编译过程？ 了解静态库与动态库么？说说静态链接与动态链接的实现思路 知道内部链接与外部链接么？ extern与static delegate是什么？实现思路？与event的区别？ 使用过模板么？了解哪些特性？ 模板代码如何组织？模板的编译（以及实例化）过程 听说过转发构造么？ 描述一下函数调用过程中栈的变化 __cdecl/__stdcall是什么意思 C++中四种Cast的使用场景是什么？ 用过或很熟悉的设计模式有哪些 为什么const修饰成员函数后不能修改成员变量 编码了解么？unicode和utf-8的区别 ","date":"1991-10-18","objectID":"/%E9%9D%A2%E8%AF%95%E7%82%B9/:0:0","tags":null,"title":"面试点","uri":"/%E9%9D%A2%E8%AF%95%E7%82%B9/"}]