// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ClownServerMessage.proto

#ifndef PROTOBUF_ClownServerMessage_2eproto__INCLUDED
#define PROTOBUF_ClownServerMessage_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace com {
namespace ourgame {
namespace clown {
namespace msg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ClownServerMessage_2eproto();
void protobuf_AssignDesc_ClownServerMessage_2eproto();
void protobuf_ShutdownFile_ClownServerMessage_2eproto();

class DuxLiveTick;
class ReqLogin;
class AckLogin;
class ReqChipIn;
class AckChipInResult;
class ReqCharge;
class AckCharge;
class AckEntityAward;
class ReqFillUserInfo;
class AckFillUserInfo;
class EntityAward;
class ReqActivityAwardList;
class AckActivityAwardList;
class ReqEntityAwardHistory;
class AckEntityAwardHistory;
class ReqBet;
class AckBet;
class AckTipMessage;
class AckHugeAward;
class AckDoubleChanceAward;
class AckLoseTooMuch;
class AckCloseConnection;
class ReqOpenClown;
class AckOpenClown;
class ReqCloseClown;
class AckCloseClown;
class AckServerInMaintaining;
class AckPoolValue;
class ReqRankingList;
class AckRankingList;
class AckRankingList_RankInfo;
class ReqHandselAwardHistory;
class AckHandselAwardHistory;
class AckHandselAwardHistory_HandselAward;
class AckIncreaseExpActivity;
class ReqDegrade;
class ReqNewActivityInfo;
class AckNewActivityInfo;
class AckNewActivityInfo_NewActivity;
class ReqBox;
class AckBox;
class AckUserMoney;
class AckDegradeTime;
class ReqOrAccordRecharge;
class AckOrAccordRecharge;
class ReqAuthCode;
class AckAuthCode;
class ReqUserRecharge;
class AckUserRecharge;
class ReqMobleRecharge;
class AckMobleRecharge;
class ReqPopMobleRecharge;
class AckPopMobleRecharge;
class AckWndAwardNotice;
class ReqNewGuideResult;
class ackLotteryAward;
class ReqSendHorn;
class ReqBetFromOthers;
class ReqUserMoney;

// ===================================================================

class DuxLiveTick : public ::google::protobuf::Message {
 public:
  DuxLiveTick();
  virtual ~DuxLiveTick();
  
  DuxLiveTick(const DuxLiveTick& from);
  
  inline DuxLiveTick& operator=(const DuxLiveTick& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DuxLiveTick& default_instance();
  
  void Swap(DuxLiveTick* other);
  
  // implements Message ----------------------------------------------
  
  DuxLiveTick* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DuxLiveTick& from);
  void MergeFrom(const DuxLiveTick& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int64 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:com.ourgame.clown.msg.DuxLiveTick)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 time_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_ClownServerMessage_2eproto();
  friend void protobuf_AssignDesc_ClownServerMessage_2eproto();
  friend void protobuf_ShutdownFile_ClownServerMessage_2eproto();
  
  void InitAsDefaultInstance();
  static DuxLiveTick* default_instance_;
};
// -------------------------------------------------------------------

class ReqLogin : public ::google::protobuf::Message {
 public:
  ReqLogin();
  virtual ~ReqLogin();
  
  ReqLogin(const ReqLogin& from);
  
  inline ReqLogin& operator=(const ReqLogin& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqLogin& default_instance();
  
  void Swap(ReqLogin* other);
  
  // implements Message ----------------------------------------------
  
  ReqLogin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqLogin& from);
  void MergeFrom(const ReqLogin& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string roleName = 1;
  inline bool has_rolename() const;
  inline void clear_rolename();
  static const int kRoleNameFieldNumber = 1;
  inline const ::std::string& rolename() const;
  inline void set_rolename(const ::std::string& value);
  inline void set_rolename(const char* value);
  inline void set_rolename(const char* value, size_t size);
  inline ::std::string* mutable_rolename();
  inline ::std::string* release_rolename();
  
  // optional int64 userId = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::int64 userid() const;
  inline void set_userid(::google::protobuf::int64 value);
  
  // required string userName = 3;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUserNameFieldNumber = 3;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  
  // optional string password = 4;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 4;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  
  // optional int32 fatherGameId = 5;
  inline bool has_fathergameid() const;
  inline void clear_fathergameid();
  static const int kFatherGameIdFieldNumber = 5;
  inline ::google::protobuf::int32 fathergameid() const;
  inline void set_fathergameid(::google::protobuf::int32 value);
  
  // optional string loaderURL = 6;
  inline bool has_loaderurl() const;
  inline void clear_loaderurl();
  static const int kLoaderURLFieldNumber = 6;
  inline const ::std::string& loaderurl() const;
  inline void set_loaderurl(const ::std::string& value);
  inline void set_loaderurl(const char* value);
  inline void set_loaderurl(const char* value, size_t size);
  inline ::std::string* mutable_loaderurl();
  inline ::std::string* release_loaderurl();
  
  // optional bool force = 7;
  inline bool has_force() const;
  inline void clear_force();
  static const int kForceFieldNumber = 7;
  inline bool force() const;
  inline void set_force(bool value);
  
  // optional string ticket = 8;
  inline bool has_ticket() const;
  inline void clear_ticket();
  static const int kTicketFieldNumber = 8;
  inline const ::std::string& ticket() const;
  inline void set_ticket(const ::std::string& value);
  inline void set_ticket(const char* value);
  inline void set_ticket(const char* value, size_t size);
  inline ::std::string* mutable_ticket();
  inline ::std::string* release_ticket();
  
  // optional uint64 ipAddress = 9;
  inline bool has_ipaddress() const;
  inline void clear_ipaddress();
  static const int kIpAddressFieldNumber = 9;
  inline ::google::protobuf::uint64 ipaddress() const;
  inline void set_ipaddress(::google::protobuf::uint64 value);
  
  // optional uint32 gameId = 10;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 10;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);
  
  // optional uint32 moneyType = 11;
  inline bool has_moneytype() const;
  inline void clear_moneytype();
  static const int kMoneyTypeFieldNumber = 11;
  inline ::google::protobuf::uint32 moneytype() const;
  inline void set_moneytype(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:com.ourgame.clown.msg.ReqLogin)
 private:
  inline void set_has_rolename();
  inline void clear_has_rolename();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_fathergameid();
  inline void clear_has_fathergameid();
  inline void set_has_loaderurl();
  inline void clear_has_loaderurl();
  inline void set_has_force();
  inline void clear_has_force();
  inline void set_has_ticket();
  inline void clear_has_ticket();
  inline void set_has_ipaddress();
  inline void clear_has_ipaddress();
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_moneytype();
  inline void clear_has_moneytype();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* rolename_;
  ::google::protobuf::int64 userid_;
  ::std::string* username_;
  ::std::string* password_;
  ::std::string* loaderurl_;
  ::google::protobuf::int32 fathergameid_;
  bool force_;
  ::std::string* ticket_;
  ::google::protobuf::uint64 ipaddress_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 moneytype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  friend void  protobuf_AddDesc_ClownServerMessage_2eproto();
  friend void protobuf_AssignDesc_ClownServerMessage_2eproto();
  friend void protobuf_ShutdownFile_ClownServerMessage_2eproto();
  
  void InitAsDefaultInstance();
  static ReqLogin* default_instance_;
};
// -------------------------------------------------------------------

class AckLogin : public ::google::protobuf::Message {
 public:
  AckLogin();
  virtual ~AckLogin();
  
  AckLogin(const AckLogin& from);
  
  inline AckLogin& operator=(const AckLogin& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AckLogin& default_instance();
  
  void Swap(AckLogin* other);
  
  // implements Message ----------------------------------------------
  
  AckLogin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckLogin& from);
  void MergeFrom(const AckLogin& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int64 sessionId = 1;
  inline bool has_sessionid() const;
  inline void clear_sessionid();
  static const int kSessionIdFieldNumber = 1;
  inline ::google::protobuf::int64 sessionid() const;
  inline void set_sessionid(::google::protobuf::int64 value);
  
  // required int32 success = 2;
  inline bool has_success() const;
  inline void clear_success();
  static const int kSuccessFieldNumber = 2;
  inline ::google::protobuf::int32 success() const;
  inline void set_success(::google::protobuf::int32 value);
  
  // optional string failReason = 3;
  inline bool has_failreason() const;
  inline void clear_failreason();
  static const int kFailReasonFieldNumber = 3;
  inline const ::std::string& failreason() const;
  inline void set_failreason(const ::std::string& value);
  inline void set_failreason(const char* value);
  inline void set_failreason(const char* value, size_t size);
  inline ::std::string* mutable_failreason();
  inline ::std::string* release_failreason();
  
  // optional int64 userId = 4;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 4;
  inline ::google::protobuf::int64 userid() const;
  inline void set_userid(::google::protobuf::int64 value);
  
  // optional string username = 5;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 5;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  
  // optional int64 userMoney = 6;
  inline bool has_usermoney() const;
  inline void clear_usermoney();
  static const int kUserMoneyFieldNumber = 6;
  inline ::google::protobuf::int64 usermoney() const;
  inline void set_usermoney(::google::protobuf::int64 value);
  
  // optional int32 playTimes = 7;
  inline bool has_playtimes() const;
  inline void clear_playtimes();
  static const int kPlayTimesFieldNumber = 7;
  inline ::google::protobuf::int32 playtimes() const;
  inline void set_playtimes(::google::protobuf::int32 value);
  
  // optional int32 doubleTimes = 8;
  inline bool has_doubletimes() const;
  inline void clear_doubletimes();
  static const int kDoubleTimesFieldNumber = 8;
  inline ::google::protobuf::int32 doubletimes() const;
  inline void set_doubletimes(::google::protobuf::int32 value);
  
  // optional int32 is_guide = 9;
  inline bool has_is_guide() const;
  inline void clear_is_guide();
  static const int kIsGuideFieldNumber = 9;
  inline ::google::protobuf::int32 is_guide() const;
  inline void set_is_guide(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ourgame.clown.msg.AckLogin)
 private:
  inline void set_has_sessionid();
  inline void clear_has_sessionid();
  inline void set_has_success();
  inline void clear_has_success();
  inline void set_has_failreason();
  inline void clear_has_failreason();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_usermoney();
  inline void clear_has_usermoney();
  inline void set_has_playtimes();
  inline void clear_has_playtimes();
  inline void set_has_doubletimes();
  inline void clear_has_doubletimes();
  inline void set_has_is_guide();
  inline void clear_has_is_guide();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 sessionid_;
  ::std::string* failreason_;
  ::google::protobuf::int64 userid_;
  ::google::protobuf::int32 success_;
  ::google::protobuf::int32 playtimes_;
  ::std::string* username_;
  ::google::protobuf::int64 usermoney_;
  ::google::protobuf::int32 doubletimes_;
  ::google::protobuf::int32 is_guide_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_ClownServerMessage_2eproto();
  friend void protobuf_AssignDesc_ClownServerMessage_2eproto();
  friend void protobuf_ShutdownFile_ClownServerMessage_2eproto();
  
  void InitAsDefaultInstance();
  static AckLogin* default_instance_;
};
// -------------------------------------------------------------------

class ReqChipIn : public ::google::protobuf::Message {
 public:
  ReqChipIn();
  virtual ~ReqChipIn();
  
  ReqChipIn(const ReqChipIn& from);
  
  inline ReqChipIn& operator=(const ReqChipIn& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqChipIn& default_instance();
  
  void Swap(ReqChipIn* other);
  
  // implements Message ----------------------------------------------
  
  ReqChipIn* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqChipIn& from);
  void MergeFrom(const ReqChipIn& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int64 sessionId = 1;
  inline bool has_sessionid() const;
  inline void clear_sessionid();
  static const int kSessionIdFieldNumber = 1;
  inline ::google::protobuf::int64 sessionid() const;
  inline void set_sessionid(::google::protobuf::int64 value);
  
  // required int64 ante = 2;
  inline bool has_ante() const;
  inline void clear_ante();
  static const int kAnteFieldNumber = 2;
  inline ::google::protobuf::int64 ante() const;
  inline void set_ante(::google::protobuf::int64 value);
  
  // optional bool useDouble = 3;
  inline bool has_usedouble() const;
  inline void clear_usedouble();
  static const int kUseDoubleFieldNumber = 3;
  inline bool usedouble() const;
  inline void set_usedouble(bool value);
  
  // @@protoc_insertion_point(class_scope:com.ourgame.clown.msg.ReqChipIn)
 private:
  inline void set_has_sessionid();
  inline void clear_has_sessionid();
  inline void set_has_ante();
  inline void clear_has_ante();
  inline void set_has_usedouble();
  inline void clear_has_usedouble();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 sessionid_;
  ::google::protobuf::int64 ante_;
  bool usedouble_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_ClownServerMessage_2eproto();
  friend void protobuf_AssignDesc_ClownServerMessage_2eproto();
  friend void protobuf_ShutdownFile_ClownServerMessage_2eproto();
  
  void InitAsDefaultInstance();
  static ReqChipIn* default_instance_;
};
// -------------------------------------------------------------------

class AckChipInResult : public ::google::protobuf::Message {
 public:
  AckChipInResult();
  virtual ~AckChipInResult();
  
  AckChipInResult(const AckChipInResult& from);
  
  inline AckChipInResult& operator=(const AckChipInResult& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AckChipInResult& default_instance();
  
  void Swap(AckChipInResult* other);
  
  // implements Message ----------------------------------------------
  
  AckChipInResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckChipInResult& from);
  void MergeFrom(const AckChipInResult& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int64 sessionId = 1;
  inline bool has_sessionid() const;
  inline void clear_sessionid();
  static const int kSessionIdFieldNumber = 1;
  inline ::google::protobuf::int64 sessionid() const;
  inline void set_sessionid(::google::protobuf::int64 value);
  
  // required string patterns = 2;
  inline bool has_patterns() const;
  inline void clear_patterns();
  static const int kPatternsFieldNumber = 2;
  inline const ::std::string& patterns() const;
  inline void set_patterns(const ::std::string& value);
  inline void set_patterns(const char* value);
  inline void set_patterns(const char* value, size_t size);
  inline ::std::string* mutable_patterns();
  inline ::std::string* release_patterns();
  
  // required int64 awardMoney = 3;
  inline bool has_awardmoney() const;
  inline void clear_awardmoney();
  static const int kAwardMoneyFieldNumber = 3;
  inline ::google::protobuf::int64 awardmoney() const;
  inline void set_awardmoney(::google::protobuf::int64 value);
  
  // required int64 userMoney = 4;
  inline bool has_usermoney() const;
  inline void clear_usermoney();
  static const int kUserMoneyFieldNumber = 4;
  inline ::google::protobuf::int64 usermoney() const;
  inline void set_usermoney(::google::protobuf::int64 value);
  
  // optional int32 awardIndex = 5;
  inline bool has_awardindex() const;
  inline void clear_awardindex();
  static const int kAwardIndexFieldNumber = 5;
  inline ::google::protobuf::int32 awardindex() const;
  inline void set_awardindex(::google::protobuf::int32 value);
  
  // optional int32 playTimes = 6;
  inline bool has_playtimes() const;
  inline void clear_playtimes();
  static const int kPlayTimesFieldNumber = 6;
  inline ::google::protobuf::int32 playtimes() const;
  inline void set_playtimes(::google::protobuf::int32 value);
  
  // optional int32 doubleTimes = 7;
  inline bool has_doubletimes() const;
  inline void clear_doubletimes();
  static const int kDoubleTimesFieldNumber = 7;
  inline ::google::protobuf::int32 doubletimes() const;
  inline void set_doubletimes(::google::protobuf::int32 value);
  
  // required bool canBet = 8;
  inline bool has_canbet() const;
  inline void clear_canbet();
  static const int kCanBetFieldNumber = 8;
  inline bool canbet() const;
  inline void set_canbet(bool value);
  
  // required bool canDoubleBet = 9;
  inline bool has_candoublebet() const;
  inline void clear_candoublebet();
  static const int kCanDoubleBetFieldNumber = 9;
  inline bool candoublebet() const;
  inline void set_candoublebet(bool value);
  
  // @@protoc_insertion_point(class_scope:com.ourgame.clown.msg.AckChipInResult)
 private:
  inline void set_has_sessionid();
  inline void clear_has_sessionid();
  inline void set_has_patterns();
  inline void clear_has_patterns();
  inline void set_has_awardmoney();
  inline void clear_has_awardmoney();
  inline void set_has_usermoney();
  inline void clear_has_usermoney();
  inline void set_has_awardindex();
  inline void clear_has_awardindex();
  inline void set_has_playtimes();
  inline void clear_has_playtimes();
  inline void set_has_doubletimes();
  inline void clear_has_doubletimes();
  inline void set_has_canbet();
  inline void clear_has_canbet();
  inline void set_has_candoublebet();
  inline void clear_has_candoublebet();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 sessionid_;
  ::std::string* patterns_;
  ::google::protobuf::int64 awardmoney_;
  ::google::protobuf::int64 usermoney_;
  ::google::protobuf::int32 awardindex_;
  ::google::protobuf::int32 playtimes_;
  ::google::protobuf::int32 doubletimes_;
  bool canbet_;
  bool candoublebet_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_ClownServerMessage_2eproto();
  friend void protobuf_AssignDesc_ClownServerMessage_2eproto();
  friend void protobuf_ShutdownFile_ClownServerMessage_2eproto();
  
  void InitAsDefaultInstance();
  static AckChipInResult* default_instance_;
};
// -------------------------------------------------------------------

class ReqCharge : public ::google::protobuf::Message {
 public:
  ReqCharge();
  virtual ~ReqCharge();
  
  ReqCharge(const ReqCharge& from);
  
  inline ReqCharge& operator=(const ReqCharge& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqCharge& default_instance();
  
  void Swap(ReqCharge* other);
  
  // implements Message ----------------------------------------------
  
  ReqCharge* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqCharge& from);
  void MergeFrom(const ReqCharge& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int64 sessionId = 1;
  inline bool has_sessionid() const;
  inline void clear_sessionid();
  static const int kSessionIdFieldNumber = 1;
  inline ::google::protobuf::int64 sessionid() const;
  inline void set_sessionid(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:com.ourgame.clown.msg.ReqCharge)
 private:
  inline void set_has_sessionid();
  inline void clear_has_sessionid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 sessionid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_ClownServerMessage_2eproto();
  friend void protobuf_AssignDesc_ClownServerMessage_2eproto();
  friend void protobuf_ShutdownFile_ClownServerMessage_2eproto();
  
  void InitAsDefaultInstance();
  static ReqCharge* default_instance_;
};
// -------------------------------------------------------------------

class AckCharge : public ::google::protobuf::Message {
 public:
  AckCharge();
  virtual ~AckCharge();
  
  AckCharge(const AckCharge& from);
  
  inline AckCharge& operator=(const AckCharge& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AckCharge& default_instance();
  
  void Swap(AckCharge* other);
  
  // implements Message ----------------------------------------------
  
  AckCharge* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckCharge& from);
  void MergeFrom(const AckCharge& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int64 sessionId = 1;
  inline bool has_sessionid() const;
  inline void clear_sessionid();
  static const int kSessionIdFieldNumber = 1;
  inline ::google::protobuf::int64 sessionid() const;
  inline void set_sessionid(::google::protobuf::int64 value);
  
  // required bool success = 2;
  inline bool has_success() const;
  inline void clear_success();
  static const int kSuccessFieldNumber = 2;
  inline bool success() const;
  inline void set_success(bool value);
  
  // required int64 userMoney = 3;
  inline bool has_usermoney() const;
  inline void clear_usermoney();
  static const int kUserMoneyFieldNumber = 3;
  inline ::google::protobuf::int64 usermoney() const;
  inline void set_usermoney(::google::protobuf::int64 value);
  
  // optional int64 extraAward = 4;
  inline bool has_extraaward() const;
  inline void clear_extraaward();
  static const int kExtraAwardFieldNumber = 4;
  inline ::google::protobuf::int64 extraaward() const;
  inline void set_extraaward(::google::protobuf::int64 value);
  
  // optional int32 persent = 5;
  inline bool has_persent() const;
  inline void clear_persent();
  static const int kPersentFieldNumber = 5;
  inline ::google::protobuf::int32 persent() const;
  inline void set_persent(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ourgame.clown.msg.AckCharge)
 private:
  inline void set_has_sessionid();
  inline void clear_has_sessionid();
  inline void set_has_success();
  inline void clear_has_success();
  inline void set_has_usermoney();
  inline void clear_has_usermoney();
  inline void set_has_extraaward();
  inline void clear_has_extraaward();
  inline void set_has_persent();
  inline void clear_has_persent();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 sessionid_;
  ::google::protobuf::int64 usermoney_;
  bool success_;
  ::google::protobuf::int32 persent_;
  ::google::protobuf::int64 extraaward_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_ClownServerMessage_2eproto();
  friend void protobuf_AssignDesc_ClownServerMessage_2eproto();
  friend void protobuf_ShutdownFile_ClownServerMessage_2eproto();
  
  void InitAsDefaultInstance();
  static AckCharge* default_instance_;
};
// -------------------------------------------------------------------

class AckEntityAward : public ::google::protobuf::Message {
 public:
  AckEntityAward();
  virtual ~AckEntityAward();
  
  AckEntityAward(const AckEntityAward& from);
  
  inline AckEntityAward& operator=(const AckEntityAward& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AckEntityAward& default_instance();
  
  void Swap(AckEntityAward* other);
  
  // implements Message ----------------------------------------------
  
  AckEntityAward* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckEntityAward& from);
  void MergeFrom(const AckEntityAward& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);
  
  // required uint32 amount = 2;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 2;
  inline ::google::protobuf::uint32 amount() const;
  inline void set_amount(::google::protobuf::uint32 value);
  
  // required string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required string unit = 4;
  inline bool has_unit() const;
  inline void clear_unit();
  static const int kUnitFieldNumber = 4;
  inline const ::std::string& unit() const;
  inline void set_unit(const ::std::string& value);
  inline void set_unit(const char* value);
  inline void set_unit(const char* value, size_t size);
  inline ::std::string* mutable_unit();
  inline ::std::string* release_unit();
  
  // required string url = 5;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 5;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  
  // @@protoc_insertion_point(class_scope:com.ourgame.clown.msg.AckEntityAward)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_unit();
  inline void clear_has_unit();
  inline void set_has_url();
  inline void clear_has_url();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 amount_;
  ::std::string* name_;
  ::std::string* unit_;
  ::std::string* url_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_ClownServerMessage_2eproto();
  friend void protobuf_AssignDesc_ClownServerMessage_2eproto();
  friend void protobuf_ShutdownFile_ClownServerMessage_2eproto();
  
  void InitAsDefaultInstance();
  static AckEntityAward* default_instance_;
};
// -------------------------------------------------------------------

class ReqFillUserInfo : public ::google::protobuf::Message {
 public:
  ReqFillUserInfo();
  virtual ~ReqFillUserInfo();
  
  ReqFillUserInfo(const ReqFillUserInfo& from);
  
  inline ReqFillUserInfo& operator=(const ReqFillUserInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqFillUserInfo& default_instance();
  
  void Swap(ReqFillUserInfo* other);
  
  // implements Message ----------------------------------------------
  
  ReqFillUserInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqFillUserInfo& from);
  void MergeFrom(const ReqFillUserInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string realName = 1;
  inline bool has_realname() const;
  inline void clear_realname();
  static const int kRealNameFieldNumber = 1;
  inline const ::std::string& realname() const;
  inline void set_realname(const ::std::string& value);
  inline void set_realname(const char* value);
  inline void set_realname(const char* value, size_t size);
  inline ::std::string* mutable_realname();
  inline ::std::string* release_realname();
  
  // required string mobile = 2;
  inline bool has_mobile() const;
  inline void clear_mobile();
  static const int kMobileFieldNumber = 2;
  inline const ::std::string& mobile() const;
  inline void set_mobile(const ::std::string& value);
  inline void set_mobile(const char* value);
  inline void set_mobile(const char* value, size_t size);
  inline ::std::string* mutable_mobile();
  inline ::std::string* release_mobile();
  
  // required string address = 3;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 3;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const char* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  
  // required string zipCode = 4;
  inline bool has_zipcode() const;
  inline void clear_zipcode();
  static const int kZipCodeFieldNumber = 4;
  inline const ::std::string& zipcode() const;
  inline void set_zipcode(const ::std::string& value);
  inline void set_zipcode(const char* value);
  inline void set_zipcode(const char* value, size_t size);
  inline ::std::string* mutable_zipcode();
  inline ::std::string* release_zipcode();
  
  // required string idcard = 5;
  inline bool has_idcard() const;
  inline void clear_idcard();
  static const int kIdcardFieldNumber = 5;
  inline const ::std::string& idcard() const;
  inline void set_idcard(const ::std::string& value);
  inline void set_idcard(const char* value);
  inline void set_idcard(const char* value, size_t size);
  inline ::std::string* mutable_idcard();
  inline ::std::string* release_idcard();
  
  // optional string areaCode = 6;
  inline bool has_areacode() const;
  inline void clear_areacode();
  static const int kAreaCodeFieldNumber = 6;
  inline const ::std::string& areacode() const;
  inline void set_areacode(const ::std::string& value);
  inline void set_areacode(const char* value);
  inline void set_areacode(const char* value, size_t size);
  inline ::std::string* mutable_areacode();
  inline ::std::string* release_areacode();
  
  // optional string phone = 7;
  inline bool has_phone() const;
  inline void clear_phone();
  static const int kPhoneFieldNumber = 7;
  inline const ::std::string& phone() const;
  inline void set_phone(const ::std::string& value);
  inline void set_phone(const char* value);
  inline void set_phone(const char* value, size_t size);
  inline ::std::string* mutable_phone();
  inline ::std::string* release_phone();
  
  // optional string memo = 8;
  inline bool has_memo() const;
  inline void clear_memo();
  static const int kMemoFieldNumber = 8;
  inline const ::std::string& memo() const;
  inline void set_memo(const ::std::string& value);
  inline void set_memo(const char* value);
  inline void set_memo(const char* value, size_t size);
  inline ::std::string* mutable_memo();
  inline ::std::string* release_memo();
  
  // @@protoc_insertion_point(class_scope:com.ourgame.clown.msg.ReqFillUserInfo)
 private:
  inline void set_has_realname();
  inline void clear_has_realname();
  inline void set_has_mobile();
  inline void clear_has_mobile();
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_zipcode();
  inline void clear_has_zipcode();
  inline void set_has_idcard();
  inline void clear_has_idcard();
  inline void set_has_areacode();
  inline void clear_has_areacode();
  inline void set_has_phone();
  inline void clear_has_phone();
  inline void set_has_memo();
  inline void clear_has_memo();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* realname_;
  ::std::string* mobile_;
  ::std::string* address_;
  ::std::string* zipcode_;
  ::std::string* idcard_;
  ::std::string* areacode_;
  ::std::string* phone_;
  ::std::string* memo_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_ClownServerMessage_2eproto();
  friend void protobuf_AssignDesc_ClownServerMessage_2eproto();
  friend void protobuf_ShutdownFile_ClownServerMessage_2eproto();
  
  void InitAsDefaultInstance();
  static ReqFillUserInfo* default_instance_;
};
// -------------------------------------------------------------------

class AckFillUserInfo : public ::google::protobuf::Message {
 public:
  AckFillUserInfo();
  virtual ~AckFillUserInfo();
  
  AckFillUserInfo(const AckFillUserInfo& from);
  
  inline AckFillUserInfo& operator=(const AckFillUserInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AckFillUserInfo& default_instance();
  
  void Swap(AckFillUserInfo* other);
  
  // implements Message ----------------------------------------------
  
  AckFillUserInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckFillUserInfo& from);
  void MergeFrom(const AckFillUserInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 success = 1;
  inline bool has_success() const;
  inline void clear_success();
  static const int kSuccessFieldNumber = 1;
  inline ::google::protobuf::int32 success() const;
  inline void set_success(::google::protobuf::int32 value);
  
  // optional string failReson = 2;
  inline bool has_failreson() const;
  inline void clear_failreson();
  static const int kFailResonFieldNumber = 2;
  inline const ::std::string& failreson() const;
  inline void set_failreson(const ::std::string& value);
  inline void set_failreson(const char* value);
  inline void set_failreson(const char* value, size_t size);
  inline ::std::string* mutable_failreson();
  inline ::std::string* release_failreson();
  
  // @@protoc_insertion_point(class_scope:com.ourgame.clown.msg.AckFillUserInfo)
 private:
  inline void set_has_success();
  inline void clear_has_success();
  inline void set_has_failreson();
  inline void clear_has_failreson();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* failreson_;
  ::google::protobuf::int32 success_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ClownServerMessage_2eproto();
  friend void protobuf_AssignDesc_ClownServerMessage_2eproto();
  friend void protobuf_ShutdownFile_ClownServerMessage_2eproto();
  
  void InitAsDefaultInstance();
  static AckFillUserInfo* default_instance_;
};
// -------------------------------------------------------------------

class EntityAward : public ::google::protobuf::Message {
 public:
  EntityAward();
  virtual ~EntityAward();
  
  EntityAward(const EntityAward& from);
  
  inline EntityAward& operator=(const EntityAward& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const EntityAward& default_instance();
  
  void Swap(EntityAward* other);
  
  // implements Message ----------------------------------------------
  
  EntityAward* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EntityAward& from);
  void MergeFrom(const EntityAward& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // required string nickname = 2;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNicknameFieldNumber = 2;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  
  // required string date = 3;
  inline bool has_date() const;
  inline void clear_date();
  static const int kDateFieldNumber = 3;
  inline const ::std::string& date() const;
  inline void set_date(const ::std::string& value);
  inline void set_date(const char* value);
  inline void set_date(const char* value, size_t size);
  inline ::std::string* mutable_date();
  inline ::std::string* release_date();
  
  // required uint64 amount = 4;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 4;
  inline ::google::protobuf::uint64 amount() const;
  inline void set_amount(::google::protobuf::uint64 value);
  
  // required string unit = 5;
  inline bool has_unit() const;
  inline void clear_unit();
  static const int kUnitFieldNumber = 5;
  inline const ::std::string& unit() const;
  inline void set_unit(const ::std::string& value);
  inline void set_unit(const char* value);
  inline void set_unit(const char* value, size_t size);
  inline ::std::string* mutable_unit();
  inline ::std::string* release_unit();
  
  // required string name = 6;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 6;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // @@protoc_insertion_point(class_scope:com.ourgame.clown.msg.EntityAward)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_nickname();
  inline void clear_has_nickname();
  inline void set_has_date();
  inline void clear_has_date();
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_unit();
  inline void clear_has_unit();
  inline void set_has_name();
  inline void clear_has_name();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* nickname_;
  ::std::string* date_;
  ::google::protobuf::uint64 amount_;
  ::std::string* unit_;
  ::std::string* name_;
  ::google::protobuf::int32 id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_ClownServerMessage_2eproto();
  friend void protobuf_AssignDesc_ClownServerMessage_2eproto();
  friend void protobuf_ShutdownFile_ClownServerMessage_2eproto();
  
  void InitAsDefaultInstance();
  static EntityAward* default_instance_;
};
// -------------------------------------------------------------------

class ReqActivityAwardList : public ::google::protobuf::Message {
 public:
  ReqActivityAwardList();
  virtual ~ReqActivityAwardList();
  
  ReqActivityAwardList(const ReqActivityAwardList& from);
  
  inline ReqActivityAwardList& operator=(const ReqActivityAwardList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqActivityAwardList& default_instance();
  
  void Swap(ReqActivityAwardList* other);
  
  // implements Message ----------------------------------------------
  
  ReqActivityAwardList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqActivityAwardList& from);
  void MergeFrom(const ReqActivityAwardList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 page = 1 [default = 1];
  inline bool has_page() const;
  inline void clear_page();
  static const int kPageFieldNumber = 1;
  inline ::google::protobuf::int32 page() const;
  inline void set_page(::google::protobuf::int32 value);
  
  // optional int32 size = 2 [default = 10];
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 2;
  inline ::google::protobuf::int32 size() const;
  inline void set_size(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ourgame.clown.msg.ReqActivityAwardList)
 private:
  inline void set_has_page();
  inline void clear_has_page();
  inline void set_has_size();
  inline void clear_has_size();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 page_;
  ::google::protobuf::int32 size_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ClownServerMessage_2eproto();
  friend void protobuf_AssignDesc_ClownServerMessage_2eproto();
  friend void protobuf_ShutdownFile_ClownServerMessage_2eproto();
  
  void InitAsDefaultInstance();
  static ReqActivityAwardList* default_instance_;
};
// -------------------------------------------------------------------

class AckActivityAwardList : public ::google::protobuf::Message {
 public:
  AckActivityAwardList();
  virtual ~AckActivityAwardList();
  
  AckActivityAwardList(const AckActivityAwardList& from);
  
  inline AckActivityAwardList& operator=(const AckActivityAwardList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AckActivityAwardList& default_instance();
  
  void Swap(AckActivityAwardList* other);
  
  // implements Message ----------------------------------------------
  
  AckActivityAwardList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckActivityAwardList& from);
  void MergeFrom(const AckActivityAwardList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .com.ourgame.clown.msg.EntityAward awardList = 1;
  inline int awardlist_size() const;
  inline void clear_awardlist();
  static const int kAwardListFieldNumber = 1;
  inline const ::com::ourgame::clown::msg::EntityAward& awardlist(int index) const;
  inline ::com::ourgame::clown::msg::EntityAward* mutable_awardlist(int index);
  inline ::com::ourgame::clown::msg::EntityAward* add_awardlist();
  inline const ::google::protobuf::RepeatedPtrField< ::com::ourgame::clown::msg::EntityAward >&
      awardlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::ourgame::clown::msg::EntityAward >*
      mutable_awardlist();
  
  // @@protoc_insertion_point(class_scope:com.ourgame.clown.msg.AckActivityAwardList)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::com::ourgame::clown::msg::EntityAward > awardlist_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_ClownServerMessage_2eproto();
  friend void protobuf_AssignDesc_ClownServerMessage_2eproto();
  friend void protobuf_ShutdownFile_ClownServerMessage_2eproto();
  
  void InitAsDefaultInstance();
  static AckActivityAwardList* default_instance_;
};
// -------------------------------------------------------------------

class ReqEntityAwardHistory : public ::google::protobuf::Message {
 public:
  ReqEntityAwardHistory();
  virtual ~ReqEntityAwardHistory();
  
  ReqEntityAwardHistory(const ReqEntityAwardHistory& from);
  
  inline ReqEntityAwardHistory& operator=(const ReqEntityAwardHistory& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqEntityAwardHistory& default_instance();
  
  void Swap(ReqEntityAwardHistory* other);
  
  // implements Message ----------------------------------------------
  
  ReqEntityAwardHistory* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqEntityAwardHistory& from);
  void MergeFrom(const ReqEntityAwardHistory& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 page = 1 [default = 1];
  inline bool has_page() const;
  inline void clear_page();
  static const int kPageFieldNumber = 1;
  inline ::google::protobuf::int32 page() const;
  inline void set_page(::google::protobuf::int32 value);
  
  // optional int32 size = 2 [default = 10];
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 2;
  inline ::google::protobuf::int32 size() const;
  inline void set_size(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ourgame.clown.msg.ReqEntityAwardHistory)
 private:
  inline void set_has_page();
  inline void clear_has_page();
  inline void set_has_size();
  inline void clear_has_size();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 page_;
  ::google::protobuf::int32 size_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ClownServerMessage_2eproto();
  friend void protobuf_AssignDesc_ClownServerMessage_2eproto();
  friend void protobuf_ShutdownFile_ClownServerMessage_2eproto();
  
  void InitAsDefaultInstance();
  static ReqEntityAwardHistory* default_instance_;
};
// -------------------------------------------------------------------

class AckEntityAwardHistory : public ::google::protobuf::Message {
 public:
  AckEntityAwardHistory();
  virtual ~AckEntityAwardHistory();
  
  AckEntityAwardHistory(const AckEntityAwardHistory& from);
  
  inline AckEntityAwardHistory& operator=(const AckEntityAwardHistory& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AckEntityAwardHistory& default_instance();
  
  void Swap(AckEntityAwardHistory* other);
  
  // implements Message ----------------------------------------------
  
  AckEntityAwardHistory* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckEntityAwardHistory& from);
  void MergeFrom(const AckEntityAwardHistory& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .com.ourgame.clown.msg.EntityAward awardList = 1;
  inline int awardlist_size() const;
  inline void clear_awardlist();
  static const int kAwardListFieldNumber = 1;
  inline const ::com::ourgame::clown::msg::EntityAward& awardlist(int index) const;
  inline ::com::ourgame::clown::msg::EntityAward* mutable_awardlist(int index);
  inline ::com::ourgame::clown::msg::EntityAward* add_awardlist();
  inline const ::google::protobuf::RepeatedPtrField< ::com::ourgame::clown::msg::EntityAward >&
      awardlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::ourgame::clown::msg::EntityAward >*
      mutable_awardlist();
  
  // @@protoc_insertion_point(class_scope:com.ourgame.clown.msg.AckEntityAwardHistory)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::com::ourgame::clown::msg::EntityAward > awardlist_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_ClownServerMessage_2eproto();
  friend void protobuf_AssignDesc_ClownServerMessage_2eproto();
  friend void protobuf_ShutdownFile_ClownServerMessage_2eproto();
  
  void InitAsDefaultInstance();
  static AckEntityAwardHistory* default_instance_;
};
// -------------------------------------------------------------------

class ReqBet : public ::google::protobuf::Message {
 public:
  ReqBet();
  virtual ~ReqBet();
  
  ReqBet(const ReqBet& from);
  
  inline ReqBet& operator=(const ReqBet& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqBet& default_instance();
  
  void Swap(ReqBet* other);
  
  // implements Message ----------------------------------------------
  
  ReqBet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqBet& from);
  void MergeFrom(const ReqBet& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int64 sessionId = 1;
  inline bool has_sessionid() const;
  inline void clear_sessionid();
  static const int kSessionIdFieldNumber = 1;
  inline ::google::protobuf::int64 sessionid() const;
  inline void set_sessionid(::google::protobuf::int64 value);
  
  // required int32 betType = 2;
  inline bool has_bettype() const;
  inline void clear_bettype();
  static const int kBetTypeFieldNumber = 2;
  inline ::google::protobuf::int32 bettype() const;
  inline void set_bettype(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ourgame.clown.msg.ReqBet)
 private:
  inline void set_has_sessionid();
  inline void clear_has_sessionid();
  inline void set_has_bettype();
  inline void clear_has_bettype();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 sessionid_;
  ::google::protobuf::int32 bettype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ClownServerMessage_2eproto();
  friend void protobuf_AssignDesc_ClownServerMessage_2eproto();
  friend void protobuf_ShutdownFile_ClownServerMessage_2eproto();
  
  void InitAsDefaultInstance();
  static ReqBet* default_instance_;
};
// -------------------------------------------------------------------

class AckBet : public ::google::protobuf::Message {
 public:
  AckBet();
  virtual ~AckBet();
  
  AckBet(const AckBet& from);
  
  inline AckBet& operator=(const AckBet& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AckBet& default_instance();
  
  void Swap(AckBet* other);
  
  // implements Message ----------------------------------------------
  
  AckBet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckBet& from);
  void MergeFrom(const AckBet& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int64 sessionId = 1;
  inline bool has_sessionid() const;
  inline void clear_sessionid();
  static const int kSessionIdFieldNumber = 1;
  inline ::google::protobuf::int64 sessionid() const;
  inline void set_sessionid(::google::protobuf::int64 value);
  
  // required int32 betResult = 2;
  inline bool has_betresult() const;
  inline void clear_betresult();
  static const int kBetResultFieldNumber = 2;
  inline ::google::protobuf::int32 betresult() const;
  inline void set_betresult(::google::protobuf::int32 value);
  
  // required int64 awardMoney = 3;
  inline bool has_awardmoney() const;
  inline void clear_awardmoney();
  static const int kAwardMoneyFieldNumber = 3;
  inline ::google::protobuf::int64 awardmoney() const;
  inline void set_awardmoney(::google::protobuf::int64 value);
  
  // required int64 baseAnte = 4;
  inline bool has_baseante() const;
  inline void clear_baseante();
  static const int kBaseAnteFieldNumber = 4;
  inline ::google::protobuf::int64 baseante() const;
  inline void set_baseante(::google::protobuf::int64 value);
  
  // required int32 betTimes = 5;
  inline bool has_bettimes() const;
  inline void clear_bettimes();
  static const int kBetTimesFieldNumber = 5;
  inline ::google::protobuf::int32 bettimes() const;
  inline void set_bettimes(::google::protobuf::int32 value);
  
  // required int64 userMoney = 6;
  inline bool has_usermoney() const;
  inline void clear_usermoney();
  static const int kUserMoneyFieldNumber = 6;
  inline ::google::protobuf::int64 usermoney() const;
  inline void set_usermoney(::google::protobuf::int64 value);
  
  // optional int32 nextMultiple = 7;
  inline bool has_nextmultiple() const;
  inline void clear_nextmultiple();
  static const int kNextMultipleFieldNumber = 7;
  inline ::google::protobuf::int32 nextmultiple() const;
  inline void set_nextmultiple(::google::protobuf::int32 value);
  
  // required bool canBet = 8;
  inline bool has_canbet() const;
  inline void clear_canbet();
  static const int kCanBetFieldNumber = 8;
  inline bool canbet() const;
  inline void set_canbet(bool value);
  
  // required bool canDoubleBet = 9;
  inline bool has_candoublebet() const;
  inline void clear_candoublebet();
  static const int kCanDoubleBetFieldNumber = 9;
  inline bool candoublebet() const;
  inline void set_candoublebet(bool value);
  
  // optional string tipMessage = 10;
  inline bool has_tipmessage() const;
  inline void clear_tipmessage();
  static const int kTipMessageFieldNumber = 10;
  inline const ::std::string& tipmessage() const;
  inline void set_tipmessage(const ::std::string& value);
  inline void set_tipmessage(const char* value);
  inline void set_tipmessage(const char* value, size_t size);
  inline ::std::string* mutable_tipmessage();
  inline ::std::string* release_tipmessage();
  
  // @@protoc_insertion_point(class_scope:com.ourgame.clown.msg.AckBet)
 private:
  inline void set_has_sessionid();
  inline void clear_has_sessionid();
  inline void set_has_betresult();
  inline void clear_has_betresult();
  inline void set_has_awardmoney();
  inline void clear_has_awardmoney();
  inline void set_has_baseante();
  inline void clear_has_baseante();
  inline void set_has_bettimes();
  inline void clear_has_bettimes();
  inline void set_has_usermoney();
  inline void clear_has_usermoney();
  inline void set_has_nextmultiple();
  inline void clear_has_nextmultiple();
  inline void set_has_canbet();
  inline void clear_has_canbet();
  inline void set_has_candoublebet();
  inline void clear_has_candoublebet();
  inline void set_has_tipmessage();
  inline void clear_has_tipmessage();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 sessionid_;
  ::google::protobuf::int64 awardmoney_;
  ::google::protobuf::int32 betresult_;
  ::google::protobuf::int32 bettimes_;
  ::google::protobuf::int64 baseante_;
  ::google::protobuf::int64 usermoney_;
  ::google::protobuf::int32 nextmultiple_;
  bool canbet_;
  bool candoublebet_;
  ::std::string* tipmessage_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];
  
  friend void  protobuf_AddDesc_ClownServerMessage_2eproto();
  friend void protobuf_AssignDesc_ClownServerMessage_2eproto();
  friend void protobuf_ShutdownFile_ClownServerMessage_2eproto();
  
  void InitAsDefaultInstance();
  static AckBet* default_instance_;
};
// -------------------------------------------------------------------

class AckTipMessage : public ::google::protobuf::Message {
 public:
  AckTipMessage();
  virtual ~AckTipMessage();
  
  AckTipMessage(const AckTipMessage& from);
  
  inline AckTipMessage& operator=(const AckTipMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AckTipMessage& default_instance();
  
  void Swap(AckTipMessage* other);
  
  // implements Message ----------------------------------------------
  
  AckTipMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckTipMessage& from);
  void MergeFrom(const AckTipMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int64 sessionId = 1;
  inline bool has_sessionid() const;
  inline void clear_sessionid();
  static const int kSessionIdFieldNumber = 1;
  inline ::google::protobuf::int64 sessionid() const;
  inline void set_sessionid(::google::protobuf::int64 value);
  
  // required int32 msgType = 2;
  inline bool has_msgtype() const;
  inline void clear_msgtype();
  static const int kMsgTypeFieldNumber = 2;
  inline ::google::protobuf::int32 msgtype() const;
  inline void set_msgtype(::google::protobuf::int32 value);
  
  // required string txtMsg = 3;
  inline bool has_txtmsg() const;
  inline void clear_txtmsg();
  static const int kTxtMsgFieldNumber = 3;
  inline const ::std::string& txtmsg() const;
  inline void set_txtmsg(const ::std::string& value);
  inline void set_txtmsg(const char* value);
  inline void set_txtmsg(const char* value, size_t size);
  inline ::std::string* mutable_txtmsg();
  inline ::std::string* release_txtmsg();
  
  // @@protoc_insertion_point(class_scope:com.ourgame.clown.msg.AckTipMessage)
 private:
  inline void set_has_sessionid();
  inline void clear_has_sessionid();
  inline void set_has_msgtype();
  inline void clear_has_msgtype();
  inline void set_has_txtmsg();
  inline void clear_has_txtmsg();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 sessionid_;
  ::std::string* txtmsg_;
  ::google::protobuf::int32 msgtype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_ClownServerMessage_2eproto();
  friend void protobuf_AssignDesc_ClownServerMessage_2eproto();
  friend void protobuf_ShutdownFile_ClownServerMessage_2eproto();
  
  void InitAsDefaultInstance();
  static AckTipMessage* default_instance_;
};
// -------------------------------------------------------------------

class AckHugeAward : public ::google::protobuf::Message {
 public:
  AckHugeAward();
  virtual ~AckHugeAward();
  
  AckHugeAward(const AckHugeAward& from);
  
  inline AckHugeAward& operator=(const AckHugeAward& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AckHugeAward& default_instance();
  
  void Swap(AckHugeAward* other);
  
  // implements Message ----------------------------------------------
  
  AckHugeAward* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckHugeAward& from);
  void MergeFrom(const AckHugeAward& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string username = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  
  // required int64 awardMoney = 2;
  inline bool has_awardmoney() const;
  inline void clear_awardmoney();
  static const int kAwardMoneyFieldNumber = 2;
  inline ::google::protobuf::int64 awardmoney() const;
  inline void set_awardmoney(::google::protobuf::int64 value);
  
  // required int64 awardTime = 3;
  inline bool has_awardtime() const;
  inline void clear_awardtime();
  static const int kAwardTimeFieldNumber = 3;
  inline ::google::protobuf::int64 awardtime() const;
  inline void set_awardtime(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:com.ourgame.clown.msg.AckHugeAward)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_awardmoney();
  inline void clear_has_awardmoney();
  inline void set_has_awardtime();
  inline void clear_has_awardtime();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* username_;
  ::google::protobuf::int64 awardmoney_;
  ::google::protobuf::int64 awardtime_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_ClownServerMessage_2eproto();
  friend void protobuf_AssignDesc_ClownServerMessage_2eproto();
  friend void protobuf_ShutdownFile_ClownServerMessage_2eproto();
  
  void InitAsDefaultInstance();
  static AckHugeAward* default_instance_;
};
// -------------------------------------------------------------------

class AckDoubleChanceAward : public ::google::protobuf::Message {
 public:
  AckDoubleChanceAward();
  virtual ~AckDoubleChanceAward();
  
  AckDoubleChanceAward(const AckDoubleChanceAward& from);
  
  inline AckDoubleChanceAward& operator=(const AckDoubleChanceAward& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AckDoubleChanceAward& default_instance();
  
  void Swap(AckDoubleChanceAward* other);
  
  // implements Message ----------------------------------------------
  
  AckDoubleChanceAward* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckDoubleChanceAward& from);
  void MergeFrom(const AckDoubleChanceAward& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int64 sessionId = 1;
  inline bool has_sessionid() const;
  inline void clear_sessionid();
  static const int kSessionIdFieldNumber = 1;
  inline ::google::protobuf::int64 sessionid() const;
  inline void set_sessionid(::google::protobuf::int64 value);
  
  // required int32 chance = 2;
  inline bool has_chance() const;
  inline void clear_chance();
  static const int kChanceFieldNumber = 2;
  inline ::google::protobuf::int32 chance() const;
  inline void set_chance(::google::protobuf::int32 value);
  
  // required int32 totalChance = 3;
  inline bool has_totalchance() const;
  inline void clear_totalchance();
  static const int kTotalChanceFieldNumber = 3;
  inline ::google::protobuf::int32 totalchance() const;
  inline void set_totalchance(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ourgame.clown.msg.AckDoubleChanceAward)
 private:
  inline void set_has_sessionid();
  inline void clear_has_sessionid();
  inline void set_has_chance();
  inline void clear_has_chance();
  inline void set_has_totalchance();
  inline void clear_has_totalchance();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 sessionid_;
  ::google::protobuf::int32 chance_;
  ::google::protobuf::int32 totalchance_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_ClownServerMessage_2eproto();
  friend void protobuf_AssignDesc_ClownServerMessage_2eproto();
  friend void protobuf_ShutdownFile_ClownServerMessage_2eproto();
  
  void InitAsDefaultInstance();
  static AckDoubleChanceAward* default_instance_;
};
// -------------------------------------------------------------------

class AckLoseTooMuch : public ::google::protobuf::Message {
 public:
  AckLoseTooMuch();
  virtual ~AckLoseTooMuch();
  
  AckLoseTooMuch(const AckLoseTooMuch& from);
  
  inline AckLoseTooMuch& operator=(const AckLoseTooMuch& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AckLoseTooMuch& default_instance();
  
  void Swap(AckLoseTooMuch* other);
  
  // implements Message ----------------------------------------------
  
  AckLoseTooMuch* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckLoseTooMuch& from);
  void MergeFrom(const AckLoseTooMuch& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int64 sessionId = 1;
  inline bool has_sessionid() const;
  inline void clear_sessionid();
  static const int kSessionIdFieldNumber = 1;
  inline ::google::protobuf::int64 sessionid() const;
  inline void set_sessionid(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:com.ourgame.clown.msg.AckLoseTooMuch)
 private:
  inline void set_has_sessionid();
  inline void clear_has_sessionid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 sessionid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_ClownServerMessage_2eproto();
  friend void protobuf_AssignDesc_ClownServerMessage_2eproto();
  friend void protobuf_ShutdownFile_ClownServerMessage_2eproto();
  
  void InitAsDefaultInstance();
  static AckLoseTooMuch* default_instance_;
};
// -------------------------------------------------------------------

class AckCloseConnection : public ::google::protobuf::Message {
 public:
  AckCloseConnection();
  virtual ~AckCloseConnection();
  
  AckCloseConnection(const AckCloseConnection& from);
  
  inline AckCloseConnection& operator=(const AckCloseConnection& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AckCloseConnection& default_instance();
  
  void Swap(AckCloseConnection* other);
  
  // implements Message ----------------------------------------------
  
  AckCloseConnection* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckCloseConnection& from);
  void MergeFrom(const AckCloseConnection& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int64 sessionId = 1;
  inline bool has_sessionid() const;
  inline void clear_sessionid();
  static const int kSessionIdFieldNumber = 1;
  inline ::google::protobuf::int64 sessionid() const;
  inline void set_sessionid(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:com.ourgame.clown.msg.AckCloseConnection)
 private:
  inline void set_has_sessionid();
  inline void clear_has_sessionid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 sessionid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_ClownServerMessage_2eproto();
  friend void protobuf_AssignDesc_ClownServerMessage_2eproto();
  friend void protobuf_ShutdownFile_ClownServerMessage_2eproto();
  
  void InitAsDefaultInstance();
  static AckCloseConnection* default_instance_;
};
// -------------------------------------------------------------------

class ReqOpenClown : public ::google::protobuf::Message {
 public:
  ReqOpenClown();
  virtual ~ReqOpenClown();
  
  ReqOpenClown(const ReqOpenClown& from);
  
  inline ReqOpenClown& operator=(const ReqOpenClown& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqOpenClown& default_instance();
  
  void Swap(ReqOpenClown* other);
  
  // implements Message ----------------------------------------------
  
  ReqOpenClown* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqOpenClown& from);
  void MergeFrom(const ReqOpenClown& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:com.ourgame.clown.msg.ReqOpenClown)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_ClownServerMessage_2eproto();
  friend void protobuf_AssignDesc_ClownServerMessage_2eproto();
  friend void protobuf_ShutdownFile_ClownServerMessage_2eproto();
  
  void InitAsDefaultInstance();
  static ReqOpenClown* default_instance_;
};
// -------------------------------------------------------------------

class AckOpenClown : public ::google::protobuf::Message {
 public:
  AckOpenClown();
  virtual ~AckOpenClown();
  
  AckOpenClown(const AckOpenClown& from);
  
  inline AckOpenClown& operator=(const AckOpenClown& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AckOpenClown& default_instance();
  
  void Swap(AckOpenClown* other);
  
  // implements Message ----------------------------------------------
  
  AckOpenClown* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckOpenClown& from);
  void MergeFrom(const AckOpenClown& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);
  
  // optional int64 freeMoney = 2;
  inline bool has_freemoney() const;
  inline void clear_freemoney();
  static const int kFreeMoneyFieldNumber = 2;
  inline ::google::protobuf::int64 freemoney() const;
  inline void set_freemoney(::google::protobuf::int64 value);
  
  // optional int64 exchangeMoney = 3;
  inline bool has_exchangemoney() const;
  inline void clear_exchangemoney();
  static const int kExchangeMoneyFieldNumber = 3;
  inline ::google::protobuf::int64 exchangemoney() const;
  inline void set_exchangemoney(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:com.ourgame.clown.msg.AckOpenClown)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_freemoney();
  inline void clear_has_freemoney();
  inline void set_has_exchangemoney();
  inline void clear_has_exchangemoney();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 freemoney_;
  ::google::protobuf::int64 exchangemoney_;
  ::google::protobuf::int32 result_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_ClownServerMessage_2eproto();
  friend void protobuf_AssignDesc_ClownServerMessage_2eproto();
  friend void protobuf_ShutdownFile_ClownServerMessage_2eproto();
  
  void InitAsDefaultInstance();
  static AckOpenClown* default_instance_;
};
// -------------------------------------------------------------------

class ReqCloseClown : public ::google::protobuf::Message {
 public:
  ReqCloseClown();
  virtual ~ReqCloseClown();
  
  ReqCloseClown(const ReqCloseClown& from);
  
  inline ReqCloseClown& operator=(const ReqCloseClown& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqCloseClown& default_instance();
  
  void Swap(ReqCloseClown* other);
  
  // implements Message ----------------------------------------------
  
  ReqCloseClown* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqCloseClown& from);
  void MergeFrom(const ReqCloseClown& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:com.ourgame.clown.msg.ReqCloseClown)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_ClownServerMessage_2eproto();
  friend void protobuf_AssignDesc_ClownServerMessage_2eproto();
  friend void protobuf_ShutdownFile_ClownServerMessage_2eproto();
  
  void InitAsDefaultInstance();
  static ReqCloseClown* default_instance_;
};
// -------------------------------------------------------------------

class AckCloseClown : public ::google::protobuf::Message {
 public:
  AckCloseClown();
  virtual ~AckCloseClown();
  
  AckCloseClown(const AckCloseClown& from);
  
  inline AckCloseClown& operator=(const AckCloseClown& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AckCloseClown& default_instance();
  
  void Swap(AckCloseClown* other);
  
  // implements Message ----------------------------------------------
  
  AckCloseClown* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckCloseClown& from);
  void MergeFrom(const AckCloseClown& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ourgame.clown.msg.AckCloseClown)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 result_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_ClownServerMessage_2eproto();
  friend void protobuf_AssignDesc_ClownServerMessage_2eproto();
  friend void protobuf_ShutdownFile_ClownServerMessage_2eproto();
  
  void InitAsDefaultInstance();
  static AckCloseClown* default_instance_;
};
// -------------------------------------------------------------------

class AckServerInMaintaining : public ::google::protobuf::Message {
 public:
  AckServerInMaintaining();
  virtual ~AckServerInMaintaining();
  
  AckServerInMaintaining(const AckServerInMaintaining& from);
  
  inline AckServerInMaintaining& operator=(const AckServerInMaintaining& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AckServerInMaintaining& default_instance();
  
  void Swap(AckServerInMaintaining* other);
  
  // implements Message ----------------------------------------------
  
  AckServerInMaintaining* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckServerInMaintaining& from);
  void MergeFrom(const AckServerInMaintaining& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:com.ourgame.clown.msg.AckServerInMaintaining)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_ClownServerMessage_2eproto();
  friend void protobuf_AssignDesc_ClownServerMessage_2eproto();
  friend void protobuf_ShutdownFile_ClownServerMessage_2eproto();
  
  void InitAsDefaultInstance();
  static AckServerInMaintaining* default_instance_;
};
// -------------------------------------------------------------------

class AckPoolValue : public ::google::protobuf::Message {
 public:
  AckPoolValue();
  virtual ~AckPoolValue();
  
  AckPoolValue(const AckPoolValue& from);
  
  inline AckPoolValue& operator=(const AckPoolValue& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AckPoolValue& default_instance();
  
  void Swap(AckPoolValue* other);
  
  // implements Message ----------------------------------------------
  
  AckPoolValue* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckPoolValue& from);
  void MergeFrom(const AckPoolValue& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint64 poolValue = 1;
  inline bool has_poolvalue() const;
  inline void clear_poolvalue();
  static const int kPoolValueFieldNumber = 1;
  inline ::google::protobuf::uint64 poolvalue() const;
  inline void set_poolvalue(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:com.ourgame.clown.msg.AckPoolValue)
 private:
  inline void set_has_poolvalue();
  inline void clear_has_poolvalue();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 poolvalue_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_ClownServerMessage_2eproto();
  friend void protobuf_AssignDesc_ClownServerMessage_2eproto();
  friend void protobuf_ShutdownFile_ClownServerMessage_2eproto();
  
  void InitAsDefaultInstance();
  static AckPoolValue* default_instance_;
};
// -------------------------------------------------------------------

class ReqRankingList : public ::google::protobuf::Message {
 public:
  ReqRankingList();
  virtual ~ReqRankingList();
  
  ReqRankingList(const ReqRankingList& from);
  
  inline ReqRankingList& operator=(const ReqRankingList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqRankingList& default_instance();
  
  void Swap(ReqRankingList* other);
  
  // implements Message ----------------------------------------------
  
  ReqRankingList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqRankingList& from);
  void MergeFrom(const ReqRankingList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 days = 1;
  inline bool has_days() const;
  inline void clear_days();
  static const int kDaysFieldNumber = 1;
  inline ::google::protobuf::uint32 days() const;
  inline void set_days(::google::protobuf::uint32 value);
  
  // required uint32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);
  
  // optional uint32 number = 3 [default = 10];
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 3;
  inline ::google::protobuf::uint32 number() const;
  inline void set_number(::google::protobuf::uint32 value);
  
  // optional bool containSelf = 4 [default = true];
  inline bool has_containself() const;
  inline void clear_containself();
  static const int kContainSelfFieldNumber = 4;
  inline bool containself() const;
  inline void set_containself(bool value);
  
  // optional bool strictChannel = 5 [default = false];
  inline bool has_strictchannel() const;
  inline void clear_strictchannel();
  static const int kStrictChannelFieldNumber = 5;
  inline bool strictchannel() const;
  inline void set_strictchannel(bool value);
  
  // @@protoc_insertion_point(class_scope:com.ourgame.clown.msg.ReqRankingList)
 private:
  inline void set_has_days();
  inline void clear_has_days();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_number();
  inline void clear_has_number();
  inline void set_has_containself();
  inline void clear_has_containself();
  inline void set_has_strictchannel();
  inline void clear_has_strictchannel();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 days_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 number_;
  bool containself_;
  bool strictchannel_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_ClownServerMessage_2eproto();
  friend void protobuf_AssignDesc_ClownServerMessage_2eproto();
  friend void protobuf_ShutdownFile_ClownServerMessage_2eproto();
  
  void InitAsDefaultInstance();
  static ReqRankingList* default_instance_;
};
// -------------------------------------------------------------------

class AckRankingList_RankInfo : public ::google::protobuf::Message {
 public:
  AckRankingList_RankInfo();
  virtual ~AckRankingList_RankInfo();
  
  AckRankingList_RankInfo(const AckRankingList_RankInfo& from);
  
  inline AckRankingList_RankInfo& operator=(const AckRankingList_RankInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AckRankingList_RankInfo& default_instance();
  
  void Swap(AckRankingList_RankInfo* other);
  
  // implements Message ----------------------------------------------
  
  AckRankingList_RankInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckRankingList_RankInfo& from);
  void MergeFrom(const AckRankingList_RankInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 serial = 1;
  inline bool has_serial() const;
  inline void clear_serial();
  static const int kSerialFieldNumber = 1;
  inline ::google::protobuf::uint32 serial() const;
  inline void set_serial(::google::protobuf::uint32 value);
  
  // required uint64 userId = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);
  
  // required string roleName = 3;
  inline bool has_rolename() const;
  inline void clear_rolename();
  static const int kRoleNameFieldNumber = 3;
  inline const ::std::string& rolename() const;
  inline void set_rolename(const ::std::string& value);
  inline void set_rolename(const char* value);
  inline void set_rolename(const char* value, size_t size);
  inline ::std::string* mutable_rolename();
  inline ::std::string* release_rolename();
  
  // required int64 value = 4;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 4;
  inline ::google::protobuf::int64 value() const;
  inline void set_value(::google::protobuf::int64 value);
  
  // required uint64 subValue = 5;
  inline bool has_subvalue() const;
  inline void clear_subvalue();
  static const int kSubValueFieldNumber = 5;
  inline ::google::protobuf::uint64 subvalue() const;
  inline void set_subvalue(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:com.ourgame.clown.msg.AckRankingList.RankInfo)
 private:
  inline void set_has_serial();
  inline void clear_has_serial();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_rolename();
  inline void clear_has_rolename();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_subvalue();
  inline void clear_has_subvalue();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 userid_;
  ::std::string* rolename_;
  ::google::protobuf::int64 value_;
  ::google::protobuf::uint64 subvalue_;
  ::google::protobuf::uint32 serial_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_ClownServerMessage_2eproto();
  friend void protobuf_AssignDesc_ClownServerMessage_2eproto();
  friend void protobuf_ShutdownFile_ClownServerMessage_2eproto();
  
  void InitAsDefaultInstance();
  static AckRankingList_RankInfo* default_instance_;
};
// -------------------------------------------------------------------

class AckRankingList : public ::google::protobuf::Message {
 public:
  AckRankingList();
  virtual ~AckRankingList();
  
  AckRankingList(const AckRankingList& from);
  
  inline AckRankingList& operator=(const AckRankingList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AckRankingList& default_instance();
  
  void Swap(AckRankingList* other);
  
  // implements Message ----------------------------------------------
  
  AckRankingList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckRankingList& from);
  void MergeFrom(const AckRankingList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef AckRankingList_RankInfo RankInfo;
  
  // accessors -------------------------------------------------------
  
  // required uint32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);
  
  // optional uint32 channel = 2;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 2;
  inline ::google::protobuf::uint32 channel() const;
  inline void set_channel(::google::protobuf::uint32 value);
  
  // repeated .com.ourgame.clown.msg.AckRankingList.RankInfo list = 3;
  inline int list_size() const;
  inline void clear_list();
  static const int kListFieldNumber = 3;
  inline const ::com::ourgame::clown::msg::AckRankingList_RankInfo& list(int index) const;
  inline ::com::ourgame::clown::msg::AckRankingList_RankInfo* mutable_list(int index);
  inline ::com::ourgame::clown::msg::AckRankingList_RankInfo* add_list();
  inline const ::google::protobuf::RepeatedPtrField< ::com::ourgame::clown::msg::AckRankingList_RankInfo >&
      list() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::ourgame::clown::msg::AckRankingList_RankInfo >*
      mutable_list();
  
  // @@protoc_insertion_point(class_scope:com.ourgame.clown.msg.AckRankingList)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_channel();
  inline void clear_has_channel();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 channel_;
  ::google::protobuf::RepeatedPtrField< ::com::ourgame::clown::msg::AckRankingList_RankInfo > list_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_ClownServerMessage_2eproto();
  friend void protobuf_AssignDesc_ClownServerMessage_2eproto();
  friend void protobuf_ShutdownFile_ClownServerMessage_2eproto();
  
  void InitAsDefaultInstance();
  static AckRankingList* default_instance_;
};
// -------------------------------------------------------------------

class ReqHandselAwardHistory : public ::google::protobuf::Message {
 public:
  ReqHandselAwardHistory();
  virtual ~ReqHandselAwardHistory();
  
  ReqHandselAwardHistory(const ReqHandselAwardHistory& from);
  
  inline ReqHandselAwardHistory& operator=(const ReqHandselAwardHistory& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqHandselAwardHistory& default_instance();
  
  void Swap(ReqHandselAwardHistory* other);
  
  // implements Message ----------------------------------------------
  
  ReqHandselAwardHistory* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqHandselAwardHistory& from);
  void MergeFrom(const ReqHandselAwardHistory& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);
  
  // optional uint32 rows = 2 [default = 20];
  inline bool has_rows() const;
  inline void clear_rows();
  static const int kRowsFieldNumber = 2;
  inline ::google::protobuf::uint32 rows() const;
  inline void set_rows(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:com.ourgame.clown.msg.ReqHandselAwardHistory)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_rows();
  inline void clear_has_rows();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 rows_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ClownServerMessage_2eproto();
  friend void protobuf_AssignDesc_ClownServerMessage_2eproto();
  friend void protobuf_ShutdownFile_ClownServerMessage_2eproto();
  
  void InitAsDefaultInstance();
  static ReqHandselAwardHistory* default_instance_;
};
// -------------------------------------------------------------------

class AckHandselAwardHistory_HandselAward : public ::google::protobuf::Message {
 public:
  AckHandselAwardHistory_HandselAward();
  virtual ~AckHandselAwardHistory_HandselAward();
  
  AckHandselAwardHistory_HandselAward(const AckHandselAwardHistory_HandselAward& from);
  
  inline AckHandselAwardHistory_HandselAward& operator=(const AckHandselAwardHistory_HandselAward& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AckHandselAwardHistory_HandselAward& default_instance();
  
  void Swap(AckHandselAwardHistory_HandselAward* other);
  
  // implements Message ----------------------------------------------
  
  AckHandselAwardHistory_HandselAward* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckHandselAwardHistory_HandselAward& from);
  void MergeFrom(const AckHandselAwardHistory_HandselAward& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 serial = 1;
  inline bool has_serial() const;
  inline void clear_serial();
  static const int kSerialFieldNumber = 1;
  inline ::google::protobuf::uint32 serial() const;
  inline void set_serial(::google::protobuf::uint32 value);
  
  // required string username = 2;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 2;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  
  // required string happenTime = 3;
  inline bool has_happentime() const;
  inline void clear_happentime();
  static const int kHappenTimeFieldNumber = 3;
  inline const ::std::string& happentime() const;
  inline void set_happentime(const ::std::string& value);
  inline void set_happentime(const char* value);
  inline void set_happentime(const char* value, size_t size);
  inline ::std::string* mutable_happentime();
  inline ::std::string* release_happentime();
  
  // required uint64 awardMoney = 4;
  inline bool has_awardmoney() const;
  inline void clear_awardmoney();
  static const int kAwardMoneyFieldNumber = 4;
  inline ::google::protobuf::uint64 awardmoney() const;
  inline void set_awardmoney(::google::protobuf::uint64 value);
  
  // required uint64 handselPool = 5;
  inline bool has_handselpool() const;
  inline void clear_handselpool();
  static const int kHandselPoolFieldNumber = 5;
  inline ::google::protobuf::uint64 handselpool() const;
  inline void set_handselpool(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:com.ourgame.clown.msg.AckHandselAwardHistory.HandselAward)
 private:
  inline void set_has_serial();
  inline void clear_has_serial();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_happentime();
  inline void clear_has_happentime();
  inline void set_has_awardmoney();
  inline void clear_has_awardmoney();
  inline void set_has_handselpool();
  inline void clear_has_handselpool();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* username_;
  ::std::string* happentime_;
  ::google::protobuf::uint64 awardmoney_;
  ::google::protobuf::uint64 handselpool_;
  ::google::protobuf::uint32 serial_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_ClownServerMessage_2eproto();
  friend void protobuf_AssignDesc_ClownServerMessage_2eproto();
  friend void protobuf_ShutdownFile_ClownServerMessage_2eproto();
  
  void InitAsDefaultInstance();
  static AckHandselAwardHistory_HandselAward* default_instance_;
};
// -------------------------------------------------------------------

class AckHandselAwardHistory : public ::google::protobuf::Message {
 public:
  AckHandselAwardHistory();
  virtual ~AckHandselAwardHistory();
  
  AckHandselAwardHistory(const AckHandselAwardHistory& from);
  
  inline AckHandselAwardHistory& operator=(const AckHandselAwardHistory& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AckHandselAwardHistory& default_instance();
  
  void Swap(AckHandselAwardHistory* other);
  
  // implements Message ----------------------------------------------
  
  AckHandselAwardHistory* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckHandselAwardHistory& from);
  void MergeFrom(const AckHandselAwardHistory& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef AckHandselAwardHistory_HandselAward HandselAward;
  
  // accessors -------------------------------------------------------
  
  // required uint32 type = 1 [default = 0];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);
  
  // repeated .com.ourgame.clown.msg.AckHandselAwardHistory.HandselAward history = 2;
  inline int history_size() const;
  inline void clear_history();
  static const int kHistoryFieldNumber = 2;
  inline const ::com::ourgame::clown::msg::AckHandselAwardHistory_HandselAward& history(int index) const;
  inline ::com::ourgame::clown::msg::AckHandselAwardHistory_HandselAward* mutable_history(int index);
  inline ::com::ourgame::clown::msg::AckHandselAwardHistory_HandselAward* add_history();
  inline const ::google::protobuf::RepeatedPtrField< ::com::ourgame::clown::msg::AckHandselAwardHistory_HandselAward >&
      history() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::ourgame::clown::msg::AckHandselAwardHistory_HandselAward >*
      mutable_history();
  
  // @@protoc_insertion_point(class_scope:com.ourgame.clown.msg.AckHandselAwardHistory)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::com::ourgame::clown::msg::AckHandselAwardHistory_HandselAward > history_;
  ::google::protobuf::uint32 type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ClownServerMessage_2eproto();
  friend void protobuf_AssignDesc_ClownServerMessage_2eproto();
  friend void protobuf_ShutdownFile_ClownServerMessage_2eproto();
  
  void InitAsDefaultInstance();
  static AckHandselAwardHistory* default_instance_;
};
// -------------------------------------------------------------------

class AckIncreaseExpActivity : public ::google::protobuf::Message {
 public:
  AckIncreaseExpActivity();
  virtual ~AckIncreaseExpActivity();
  
  AckIncreaseExpActivity(const AckIncreaseExpActivity& from);
  
  inline AckIncreaseExpActivity& operator=(const AckIncreaseExpActivity& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AckIncreaseExpActivity& default_instance();
  
  void Swap(AckIncreaseExpActivity* other);
  
  // implements Message ----------------------------------------------
  
  AckIncreaseExpActivity* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckIncreaseExpActivity& from);
  void MergeFrom(const AckIncreaseExpActivity& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 level = 1;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 1;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);
  
  // required int32 orLev = 2;
  inline bool has_orlev() const;
  inline void clear_orlev();
  static const int kOrLevFieldNumber = 2;
  inline ::google::protobuf::int32 orlev() const;
  inline void set_orlev(::google::protobuf::int32 value);
  
  // required int64 award = 3;
  inline bool has_award() const;
  inline void clear_award();
  static const int kAwardFieldNumber = 3;
  inline ::google::protobuf::int64 award() const;
  inline void set_award(::google::protobuf::int64 value);
  
  // required int64 curExp = 4;
  inline bool has_curexp() const;
  inline void clear_curexp();
  static const int kCurExpFieldNumber = 4;
  inline ::google::protobuf::int64 curexp() const;
  inline void set_curexp(::google::protobuf::int64 value);
  
  // required int64 maxExp = 5;
  inline bool has_maxexp() const;
  inline void clear_maxexp();
  static const int kMaxExpFieldNumber = 5;
  inline ::google::protobuf::int64 maxexp() const;
  inline void set_maxexp(::google::protobuf::int64 value);
  
  // required string title = 6;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 6;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  
  // @@protoc_insertion_point(class_scope:com.ourgame.clown.msg.AckIncreaseExpActivity)
 private:
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_orlev();
  inline void clear_has_orlev();
  inline void set_has_award();
  inline void clear_has_award();
  inline void set_has_curexp();
  inline void clear_has_curexp();
  inline void set_has_maxexp();
  inline void clear_has_maxexp();
  inline void set_has_title();
  inline void clear_has_title();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 orlev_;
  ::google::protobuf::int64 award_;
  ::google::protobuf::int64 curexp_;
  ::google::protobuf::int64 maxexp_;
  ::std::string* title_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_ClownServerMessage_2eproto();
  friend void protobuf_AssignDesc_ClownServerMessage_2eproto();
  friend void protobuf_ShutdownFile_ClownServerMessage_2eproto();
  
  void InitAsDefaultInstance();
  static AckIncreaseExpActivity* default_instance_;
};
// -------------------------------------------------------------------

class ReqDegrade : public ::google::protobuf::Message {
 public:
  ReqDegrade();
  virtual ~ReqDegrade();
  
  ReqDegrade(const ReqDegrade& from);
  
  inline ReqDegrade& operator=(const ReqDegrade& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqDegrade& default_instance();
  
  void Swap(ReqDegrade* other);
  
  // implements Message ----------------------------------------------
  
  ReqDegrade* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqDegrade& from);
  void MergeFrom(const ReqDegrade& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:com.ourgame.clown.msg.ReqDegrade)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_ClownServerMessage_2eproto();
  friend void protobuf_AssignDesc_ClownServerMessage_2eproto();
  friend void protobuf_ShutdownFile_ClownServerMessage_2eproto();
  
  void InitAsDefaultInstance();
  static ReqDegrade* default_instance_;
};
// -------------------------------------------------------------------

class ReqNewActivityInfo : public ::google::protobuf::Message {
 public:
  ReqNewActivityInfo();
  virtual ~ReqNewActivityInfo();
  
  ReqNewActivityInfo(const ReqNewActivityInfo& from);
  
  inline ReqNewActivityInfo& operator=(const ReqNewActivityInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqNewActivityInfo& default_instance();
  
  void Swap(ReqNewActivityInfo* other);
  
  // implements Message ----------------------------------------------
  
  ReqNewActivityInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqNewActivityInfo& from);
  void MergeFrom(const ReqNewActivityInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:com.ourgame.clown.msg.ReqNewActivityInfo)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_ClownServerMessage_2eproto();
  friend void protobuf_AssignDesc_ClownServerMessage_2eproto();
  friend void protobuf_ShutdownFile_ClownServerMessage_2eproto();
  
  void InitAsDefaultInstance();
  static ReqNewActivityInfo* default_instance_;
};
// -------------------------------------------------------------------

class AckNewActivityInfo_NewActivity : public ::google::protobuf::Message {
 public:
  AckNewActivityInfo_NewActivity();
  virtual ~AckNewActivityInfo_NewActivity();
  
  AckNewActivityInfo_NewActivity(const AckNewActivityInfo_NewActivity& from);
  
  inline AckNewActivityInfo_NewActivity& operator=(const AckNewActivityInfo_NewActivity& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AckNewActivityInfo_NewActivity& default_instance();
  
  void Swap(AckNewActivityInfo_NewActivity* other);
  
  // implements Message ----------------------------------------------
  
  AckNewActivityInfo_NewActivity* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckNewActivityInfo_NewActivity& from);
  void MergeFrom(const AckNewActivityInfo_NewActivity& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 actId = 1;
  inline bool has_actid() const;
  inline void clear_actid();
  static const int kActIdFieldNumber = 1;
  inline ::google::protobuf::int32 actid() const;
  inline void set_actid(::google::protobuf::int32 value);
  
  // required bool open = 2;
  inline bool has_open() const;
  inline void clear_open();
  static const int kOpenFieldNumber = 2;
  inline bool open() const;
  inline void set_open(bool value);
  
  // required string title = 3;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 3;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  
  // required int64 curExp = 4;
  inline bool has_curexp() const;
  inline void clear_curexp();
  static const int kCurExpFieldNumber = 4;
  inline ::google::protobuf::int64 curexp() const;
  inline void set_curexp(::google::protobuf::int64 value);
  
  // required int64 maxExp = 5;
  inline bool has_maxexp() const;
  inline void clear_maxexp();
  static const int kMaxExpFieldNumber = 5;
  inline ::google::protobuf::int64 maxexp() const;
  inline void set_maxexp(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:com.ourgame.clown.msg.AckNewActivityInfo.NewActivity)
 private:
  inline void set_has_actid();
  inline void clear_has_actid();
  inline void set_has_open();
  inline void clear_has_open();
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_curexp();
  inline void clear_has_curexp();
  inline void set_has_maxexp();
  inline void clear_has_maxexp();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 actid_;
  bool open_;
  ::std::string* title_;
  ::google::protobuf::int64 curexp_;
  ::google::protobuf::int64 maxexp_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_ClownServerMessage_2eproto();
  friend void protobuf_AssignDesc_ClownServerMessage_2eproto();
  friend void protobuf_ShutdownFile_ClownServerMessage_2eproto();
  
  void InitAsDefaultInstance();
  static AckNewActivityInfo_NewActivity* default_instance_;
};
// -------------------------------------------------------------------

class AckNewActivityInfo : public ::google::protobuf::Message {
 public:
  AckNewActivityInfo();
  virtual ~AckNewActivityInfo();
  
  AckNewActivityInfo(const AckNewActivityInfo& from);
  
  inline AckNewActivityInfo& operator=(const AckNewActivityInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AckNewActivityInfo& default_instance();
  
  void Swap(AckNewActivityInfo* other);
  
  // implements Message ----------------------------------------------
  
  AckNewActivityInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckNewActivityInfo& from);
  void MergeFrom(const AckNewActivityInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef AckNewActivityInfo_NewActivity NewActivity;
  
  // accessors -------------------------------------------------------
  
  // repeated .com.ourgame.clown.msg.AckNewActivityInfo.NewActivity newActivityList = 1;
  inline int newactivitylist_size() const;
  inline void clear_newactivitylist();
  static const int kNewActivityListFieldNumber = 1;
  inline const ::com::ourgame::clown::msg::AckNewActivityInfo_NewActivity& newactivitylist(int index) const;
  inline ::com::ourgame::clown::msg::AckNewActivityInfo_NewActivity* mutable_newactivitylist(int index);
  inline ::com::ourgame::clown::msg::AckNewActivityInfo_NewActivity* add_newactivitylist();
  inline const ::google::protobuf::RepeatedPtrField< ::com::ourgame::clown::msg::AckNewActivityInfo_NewActivity >&
      newactivitylist() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::ourgame::clown::msg::AckNewActivityInfo_NewActivity >*
      mutable_newactivitylist();
  
  // @@protoc_insertion_point(class_scope:com.ourgame.clown.msg.AckNewActivityInfo)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::com::ourgame::clown::msg::AckNewActivityInfo_NewActivity > newactivitylist_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_ClownServerMessage_2eproto();
  friend void protobuf_AssignDesc_ClownServerMessage_2eproto();
  friend void protobuf_ShutdownFile_ClownServerMessage_2eproto();
  
  void InitAsDefaultInstance();
  static AckNewActivityInfo* default_instance_;
};
// -------------------------------------------------------------------

class ReqBox : public ::google::protobuf::Message {
 public:
  ReqBox();
  virtual ~ReqBox();
  
  ReqBox(const ReqBox& from);
  
  inline ReqBox& operator=(const ReqBox& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqBox& default_instance();
  
  void Swap(ReqBox* other);
  
  // implements Message ----------------------------------------------
  
  ReqBox* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqBox& from);
  void MergeFrom(const ReqBox& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:com.ourgame.clown.msg.ReqBox)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_ClownServerMessage_2eproto();
  friend void protobuf_AssignDesc_ClownServerMessage_2eproto();
  friend void protobuf_ShutdownFile_ClownServerMessage_2eproto();
  
  void InitAsDefaultInstance();
  static ReqBox* default_instance_;
};
// -------------------------------------------------------------------

class AckBox : public ::google::protobuf::Message {
 public:
  AckBox();
  virtual ~AckBox();
  
  AckBox(const AckBox& from);
  
  inline AckBox& operator=(const AckBox& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AckBox& default_instance();
  
  void Swap(AckBox* other);
  
  // implements Message ----------------------------------------------
  
  AckBox* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckBox& from);
  void MergeFrom(const AckBox& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int64 award = 1;
  inline bool has_award() const;
  inline void clear_award();
  static const int kAwardFieldNumber = 1;
  inline ::google::protobuf::int64 award() const;
  inline void set_award(::google::protobuf::int64 value);
  
  // required int32 boxCount = 2;
  inline bool has_boxcount() const;
  inline void clear_boxcount();
  static const int kBoxCountFieldNumber = 2;
  inline ::google::protobuf::int32 boxcount() const;
  inline void set_boxcount(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ourgame.clown.msg.AckBox)
 private:
  inline void set_has_award();
  inline void clear_has_award();
  inline void set_has_boxcount();
  inline void clear_has_boxcount();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 award_;
  ::google::protobuf::int32 boxcount_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ClownServerMessage_2eproto();
  friend void protobuf_AssignDesc_ClownServerMessage_2eproto();
  friend void protobuf_ShutdownFile_ClownServerMessage_2eproto();
  
  void InitAsDefaultInstance();
  static AckBox* default_instance_;
};
// -------------------------------------------------------------------

class AckUserMoney : public ::google::protobuf::Message {
 public:
  AckUserMoney();
  virtual ~AckUserMoney();
  
  AckUserMoney(const AckUserMoney& from);
  
  inline AckUserMoney& operator=(const AckUserMoney& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AckUserMoney& default_instance();
  
  void Swap(AckUserMoney* other);
  
  // implements Message ----------------------------------------------
  
  AckUserMoney* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckUserMoney& from);
  void MergeFrom(const AckUserMoney& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int64 userMoney = 1;
  inline bool has_usermoney() const;
  inline void clear_usermoney();
  static const int kUserMoneyFieldNumber = 1;
  inline ::google::protobuf::int64 usermoney() const;
  inline void set_usermoney(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:com.ourgame.clown.msg.AckUserMoney)
 private:
  inline void set_has_usermoney();
  inline void clear_has_usermoney();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 usermoney_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_ClownServerMessage_2eproto();
  friend void protobuf_AssignDesc_ClownServerMessage_2eproto();
  friend void protobuf_ShutdownFile_ClownServerMessage_2eproto();
  
  void InitAsDefaultInstance();
  static AckUserMoney* default_instance_;
};
// -------------------------------------------------------------------

class AckDegradeTime : public ::google::protobuf::Message {
 public:
  AckDegradeTime();
  virtual ~AckDegradeTime();
  
  AckDegradeTime(const AckDegradeTime& from);
  
  inline AckDegradeTime& operator=(const AckDegradeTime& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AckDegradeTime& default_instance();
  
  void Swap(AckDegradeTime* other);
  
  // implements Message ----------------------------------------------
  
  AckDegradeTime* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckDegradeTime& from);
  void MergeFrom(const AckDegradeTime& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 remainTime = 1;
  inline bool has_remaintime() const;
  inline void clear_remaintime();
  static const int kRemainTimeFieldNumber = 1;
  inline ::google::protobuf::int32 remaintime() const;
  inline void set_remaintime(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ourgame.clown.msg.AckDegradeTime)
 private:
  inline void set_has_remaintime();
  inline void clear_has_remaintime();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 remaintime_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_ClownServerMessage_2eproto();
  friend void protobuf_AssignDesc_ClownServerMessage_2eproto();
  friend void protobuf_ShutdownFile_ClownServerMessage_2eproto();
  
  void InitAsDefaultInstance();
  static AckDegradeTime* default_instance_;
};
// -------------------------------------------------------------------

class ReqOrAccordRecharge : public ::google::protobuf::Message {
 public:
  ReqOrAccordRecharge();
  virtual ~ReqOrAccordRecharge();
  
  ReqOrAccordRecharge(const ReqOrAccordRecharge& from);
  
  inline ReqOrAccordRecharge& operator=(const ReqOrAccordRecharge& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqOrAccordRecharge& default_instance();
  
  void Swap(ReqOrAccordRecharge* other);
  
  // implements Message ----------------------------------------------
  
  ReqOrAccordRecharge* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqOrAccordRecharge& from);
  void MergeFrom(const ReqOrAccordRecharge& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string username = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  
  // @@protoc_insertion_point(class_scope:com.ourgame.clown.msg.ReqOrAccordRecharge)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* username_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_ClownServerMessage_2eproto();
  friend void protobuf_AssignDesc_ClownServerMessage_2eproto();
  friend void protobuf_ShutdownFile_ClownServerMessage_2eproto();
  
  void InitAsDefaultInstance();
  static ReqOrAccordRecharge* default_instance_;
};
// -------------------------------------------------------------------

class AckOrAccordRecharge : public ::google::protobuf::Message {
 public:
  AckOrAccordRecharge();
  virtual ~AckOrAccordRecharge();
  
  AckOrAccordRecharge(const AckOrAccordRecharge& from);
  
  inline AckOrAccordRecharge& operator=(const AckOrAccordRecharge& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AckOrAccordRecharge& default_instance();
  
  void Swap(AckOrAccordRecharge* other);
  
  // implements Message ----------------------------------------------
  
  AckOrAccordRecharge* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckOrAccordRecharge& from);
  void MergeFrom(const AckOrAccordRecharge& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 orCan = 1;
  inline bool has_orcan() const;
  inline void clear_orcan();
  static const int kOrCanFieldNumber = 1;
  inline ::google::protobuf::int32 orcan() const;
  inline void set_orcan(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ourgame.clown.msg.AckOrAccordRecharge)
 private:
  inline void set_has_orcan();
  inline void clear_has_orcan();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 orcan_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_ClownServerMessage_2eproto();
  friend void protobuf_AssignDesc_ClownServerMessage_2eproto();
  friend void protobuf_ShutdownFile_ClownServerMessage_2eproto();
  
  void InitAsDefaultInstance();
  static AckOrAccordRecharge* default_instance_;
};
// -------------------------------------------------------------------

class ReqAuthCode : public ::google::protobuf::Message {
 public:
  ReqAuthCode();
  virtual ~ReqAuthCode();
  
  ReqAuthCode(const ReqAuthCode& from);
  
  inline ReqAuthCode& operator=(const ReqAuthCode& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqAuthCode& default_instance();
  
  void Swap(ReqAuthCode* other);
  
  // implements Message ----------------------------------------------
  
  ReqAuthCode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqAuthCode& from);
  void MergeFrom(const ReqAuthCode& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string username = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  
  // required string tel = 2;
  inline bool has_tel() const;
  inline void clear_tel();
  static const int kTelFieldNumber = 2;
  inline const ::std::string& tel() const;
  inline void set_tel(const ::std::string& value);
  inline void set_tel(const char* value);
  inline void set_tel(const char* value, size_t size);
  inline ::std::string* mutable_tel();
  inline ::std::string* release_tel();
  
  // @@protoc_insertion_point(class_scope:com.ourgame.clown.msg.ReqAuthCode)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_tel();
  inline void clear_has_tel();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* username_;
  ::std::string* tel_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ClownServerMessage_2eproto();
  friend void protobuf_AssignDesc_ClownServerMessage_2eproto();
  friend void protobuf_ShutdownFile_ClownServerMessage_2eproto();
  
  void InitAsDefaultInstance();
  static ReqAuthCode* default_instance_;
};
// -------------------------------------------------------------------

class AckAuthCode : public ::google::protobuf::Message {
 public:
  AckAuthCode();
  virtual ~AckAuthCode();
  
  AckAuthCode(const AckAuthCode& from);
  
  inline AckAuthCode& operator=(const AckAuthCode& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AckAuthCode& default_instance();
  
  void Swap(AckAuthCode* other);
  
  // implements Message ----------------------------------------------
  
  AckAuthCode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckAuthCode& from);
  void MergeFrom(const AckAuthCode& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 sucess = 1;
  inline bool has_sucess() const;
  inline void clear_sucess();
  static const int kSucessFieldNumber = 1;
  inline ::google::protobuf::int32 sucess() const;
  inline void set_sucess(::google::protobuf::int32 value);
  
  // required string reason = 3;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 3;
  inline const ::std::string& reason() const;
  inline void set_reason(const ::std::string& value);
  inline void set_reason(const char* value);
  inline void set_reason(const char* value, size_t size);
  inline ::std::string* mutable_reason();
  inline ::std::string* release_reason();
  
  // @@protoc_insertion_point(class_scope:com.ourgame.clown.msg.AckAuthCode)
 private:
  inline void set_has_sucess();
  inline void clear_has_sucess();
  inline void set_has_reason();
  inline void clear_has_reason();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* reason_;
  ::google::protobuf::int32 sucess_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ClownServerMessage_2eproto();
  friend void protobuf_AssignDesc_ClownServerMessage_2eproto();
  friend void protobuf_ShutdownFile_ClownServerMessage_2eproto();
  
  void InitAsDefaultInstance();
  static AckAuthCode* default_instance_;
};
// -------------------------------------------------------------------

class ReqUserRecharge : public ::google::protobuf::Message {
 public:
  ReqUserRecharge();
  virtual ~ReqUserRecharge();
  
  ReqUserRecharge(const ReqUserRecharge& from);
  
  inline ReqUserRecharge& operator=(const ReqUserRecharge& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqUserRecharge& default_instance();
  
  void Swap(ReqUserRecharge* other);
  
  // implements Message ----------------------------------------------
  
  ReqUserRecharge* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqUserRecharge& from);
  void MergeFrom(const ReqUserRecharge& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string username = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  
  // required string authCode = 2;
  inline bool has_authcode() const;
  inline void clear_authcode();
  static const int kAuthCodeFieldNumber = 2;
  inline const ::std::string& authcode() const;
  inline void set_authcode(const ::std::string& value);
  inline void set_authcode(const char* value);
  inline void set_authcode(const char* value, size_t size);
  inline ::std::string* mutable_authcode();
  inline ::std::string* release_authcode();
  
  // @@protoc_insertion_point(class_scope:com.ourgame.clown.msg.ReqUserRecharge)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_authcode();
  inline void clear_has_authcode();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* username_;
  ::std::string* authcode_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ClownServerMessage_2eproto();
  friend void protobuf_AssignDesc_ClownServerMessage_2eproto();
  friend void protobuf_ShutdownFile_ClownServerMessage_2eproto();
  
  void InitAsDefaultInstance();
  static ReqUserRecharge* default_instance_;
};
// -------------------------------------------------------------------

class AckUserRecharge : public ::google::protobuf::Message {
 public:
  AckUserRecharge();
  virtual ~AckUserRecharge();
  
  AckUserRecharge(const AckUserRecharge& from);
  
  inline AckUserRecharge& operator=(const AckUserRecharge& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AckUserRecharge& default_instance();
  
  void Swap(AckUserRecharge* other);
  
  // implements Message ----------------------------------------------
  
  AckUserRecharge* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckUserRecharge& from);
  void MergeFrom(const AckUserRecharge& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int64 frecharge = 1;
  inline bool has_frecharge() const;
  inline void clear_frecharge();
  static const int kFrechargeFieldNumber = 1;
  inline ::google::protobuf::int64 frecharge() const;
  inline void set_frecharge(::google::protobuf::int64 value);
  
  // required int64 money = 2;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 2;
  inline ::google::protobuf::int64 money() const;
  inline void set_money(::google::protobuf::int64 value);
  
  // required int32 times = 3;
  inline bool has_times() const;
  inline void clear_times();
  static const int kTimesFieldNumber = 3;
  inline ::google::protobuf::int32 times() const;
  inline void set_times(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ourgame.clown.msg.AckUserRecharge)
 private:
  inline void set_has_frecharge();
  inline void clear_has_frecharge();
  inline void set_has_money();
  inline void clear_has_money();
  inline void set_has_times();
  inline void clear_has_times();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 frecharge_;
  ::google::protobuf::int64 money_;
  ::google::protobuf::int32 times_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_ClownServerMessage_2eproto();
  friend void protobuf_AssignDesc_ClownServerMessage_2eproto();
  friend void protobuf_ShutdownFile_ClownServerMessage_2eproto();
  
  void InitAsDefaultInstance();
  static AckUserRecharge* default_instance_;
};
// -------------------------------------------------------------------

class ReqMobleRecharge : public ::google::protobuf::Message {
 public:
  ReqMobleRecharge();
  virtual ~ReqMobleRecharge();
  
  ReqMobleRecharge(const ReqMobleRecharge& from);
  
  inline ReqMobleRecharge& operator=(const ReqMobleRecharge& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqMobleRecharge& default_instance();
  
  void Swap(ReqMobleRecharge* other);
  
  // implements Message ----------------------------------------------
  
  ReqMobleRecharge* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqMobleRecharge& from);
  void MergeFrom(const ReqMobleRecharge& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string username = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  
  // @@protoc_insertion_point(class_scope:com.ourgame.clown.msg.ReqMobleRecharge)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* username_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_ClownServerMessage_2eproto();
  friend void protobuf_AssignDesc_ClownServerMessage_2eproto();
  friend void protobuf_ShutdownFile_ClownServerMessage_2eproto();
  
  void InitAsDefaultInstance();
  static ReqMobleRecharge* default_instance_;
};
// -------------------------------------------------------------------

class AckMobleRecharge : public ::google::protobuf::Message {
 public:
  AckMobleRecharge();
  virtual ~AckMobleRecharge();
  
  AckMobleRecharge(const AckMobleRecharge& from);
  
  inline AckMobleRecharge& operator=(const AckMobleRecharge& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AckMobleRecharge& default_instance();
  
  void Swap(AckMobleRecharge* other);
  
  // implements Message ----------------------------------------------
  
  AckMobleRecharge* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckMobleRecharge& from);
  void MergeFrom(const AckMobleRecharge& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 success = 1;
  inline bool has_success() const;
  inline void clear_success();
  static const int kSuccessFieldNumber = 1;
  inline ::google::protobuf::int32 success() const;
  inline void set_success(::google::protobuf::int32 value);
  
  // optional string reason = 2;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 2;
  inline const ::std::string& reason() const;
  inline void set_reason(const ::std::string& value);
  inline void set_reason(const char* value);
  inline void set_reason(const char* value, size_t size);
  inline ::std::string* mutable_reason();
  inline ::std::string* release_reason();
  
  // optional int64 money = 3;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 3;
  inline ::google::protobuf::int64 money() const;
  inline void set_money(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:com.ourgame.clown.msg.AckMobleRecharge)
 private:
  inline void set_has_success();
  inline void clear_has_success();
  inline void set_has_reason();
  inline void clear_has_reason();
  inline void set_has_money();
  inline void clear_has_money();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* reason_;
  ::google::protobuf::int64 money_;
  ::google::protobuf::int32 success_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_ClownServerMessage_2eproto();
  friend void protobuf_AssignDesc_ClownServerMessage_2eproto();
  friend void protobuf_ShutdownFile_ClownServerMessage_2eproto();
  
  void InitAsDefaultInstance();
  static AckMobleRecharge* default_instance_;
};
// -------------------------------------------------------------------

class ReqPopMobleRecharge : public ::google::protobuf::Message {
 public:
  ReqPopMobleRecharge();
  virtual ~ReqPopMobleRecharge();
  
  ReqPopMobleRecharge(const ReqPopMobleRecharge& from);
  
  inline ReqPopMobleRecharge& operator=(const ReqPopMobleRecharge& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqPopMobleRecharge& default_instance();
  
  void Swap(ReqPopMobleRecharge* other);
  
  // implements Message ----------------------------------------------
  
  ReqPopMobleRecharge* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqPopMobleRecharge& from);
  void MergeFrom(const ReqPopMobleRecharge& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string username = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  
  // @@protoc_insertion_point(class_scope:com.ourgame.clown.msg.ReqPopMobleRecharge)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* username_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_ClownServerMessage_2eproto();
  friend void protobuf_AssignDesc_ClownServerMessage_2eproto();
  friend void protobuf_ShutdownFile_ClownServerMessage_2eproto();
  
  void InitAsDefaultInstance();
  static ReqPopMobleRecharge* default_instance_;
};
// -------------------------------------------------------------------

class AckPopMobleRecharge : public ::google::protobuf::Message {
 public:
  AckPopMobleRecharge();
  virtual ~AckPopMobleRecharge();
  
  AckPopMobleRecharge(const AckPopMobleRecharge& from);
  
  inline AckPopMobleRecharge& operator=(const AckPopMobleRecharge& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AckPopMobleRecharge& default_instance();
  
  void Swap(AckPopMobleRecharge* other);
  
  // implements Message ----------------------------------------------
  
  AckPopMobleRecharge* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckPopMobleRecharge& from);
  void MergeFrom(const AckPopMobleRecharge& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ourgame.clown.msg.AckPopMobleRecharge)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 result_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_ClownServerMessage_2eproto();
  friend void protobuf_AssignDesc_ClownServerMessage_2eproto();
  friend void protobuf_ShutdownFile_ClownServerMessage_2eproto();
  
  void InitAsDefaultInstance();
  static AckPopMobleRecharge* default_instance_;
};
// -------------------------------------------------------------------

class AckWndAwardNotice : public ::google::protobuf::Message {
 public:
  AckWndAwardNotice();
  virtual ~AckWndAwardNotice();
  
  AckWndAwardNotice(const AckWndAwardNotice& from);
  
  inline AckWndAwardNotice& operator=(const AckWndAwardNotice& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AckWndAwardNotice& default_instance();
  
  void Swap(AckWndAwardNotice* other);
  
  // implements Message ----------------------------------------------
  
  AckWndAwardNotice* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckWndAwardNotice& from);
  void MergeFrom(const AckWndAwardNotice& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int64 wndCount = 1;
  inline bool has_wndcount() const;
  inline void clear_wndcount();
  static const int kWndCountFieldNumber = 1;
  inline ::google::protobuf::int64 wndcount() const;
  inline void set_wndcount(::google::protobuf::int64 value);
  
  // required int64 yxdCount = 2;
  inline bool has_yxdcount() const;
  inline void clear_yxdcount();
  static const int kYxdCountFieldNumber = 2;
  inline ::google::protobuf::int64 yxdcount() const;
  inline void set_yxdcount(::google::protobuf::int64 value);
  
  // required int32 noticeType = 3;
  inline bool has_noticetype() const;
  inline void clear_noticetype();
  static const int kNoticeTypeFieldNumber = 3;
  inline ::google::protobuf::int32 noticetype() const;
  inline void set_noticetype(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ourgame.clown.msg.AckWndAwardNotice)
 private:
  inline void set_has_wndcount();
  inline void clear_has_wndcount();
  inline void set_has_yxdcount();
  inline void clear_has_yxdcount();
  inline void set_has_noticetype();
  inline void clear_has_noticetype();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 wndcount_;
  ::google::protobuf::int64 yxdcount_;
  ::google::protobuf::int32 noticetype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_ClownServerMessage_2eproto();
  friend void protobuf_AssignDesc_ClownServerMessage_2eproto();
  friend void protobuf_ShutdownFile_ClownServerMessage_2eproto();
  
  void InitAsDefaultInstance();
  static AckWndAwardNotice* default_instance_;
};
// -------------------------------------------------------------------

class ReqNewGuideResult : public ::google::protobuf::Message {
 public:
  ReqNewGuideResult();
  virtual ~ReqNewGuideResult();
  
  ReqNewGuideResult(const ReqNewGuideResult& from);
  
  inline ReqNewGuideResult& operator=(const ReqNewGuideResult& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqNewGuideResult& default_instance();
  
  void Swap(ReqNewGuideResult* other);
  
  // implements Message ----------------------------------------------
  
  ReqNewGuideResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqNewGuideResult& from);
  void MergeFrom(const ReqNewGuideResult& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string username = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  
  // required int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ourgame.clown.msg.ReqNewGuideResult)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_result();
  inline void clear_has_result();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* username_;
  ::google::protobuf::int32 result_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ClownServerMessage_2eproto();
  friend void protobuf_AssignDesc_ClownServerMessage_2eproto();
  friend void protobuf_ShutdownFile_ClownServerMessage_2eproto();
  
  void InitAsDefaultInstance();
  static ReqNewGuideResult* default_instance_;
};
// -------------------------------------------------------------------

class ackLotteryAward : public ::google::protobuf::Message {
 public:
  ackLotteryAward();
  virtual ~ackLotteryAward();
  
  ackLotteryAward(const ackLotteryAward& from);
  
  inline ackLotteryAward& operator=(const ackLotteryAward& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ackLotteryAward& default_instance();
  
  void Swap(ackLotteryAward* other);
  
  // implements Message ----------------------------------------------
  
  ackLotteryAward* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ackLotteryAward& from);
  void MergeFrom(const ackLotteryAward& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int64 sessionId = 1;
  inline bool has_sessionid() const;
  inline void clear_sessionid();
  static const int kSessionIdFieldNumber = 1;
  inline ::google::protobuf::int64 sessionid() const;
  inline void set_sessionid(::google::protobuf::int64 value);
  
  // required string patterns = 2;
  inline bool has_patterns() const;
  inline void clear_patterns();
  static const int kPatternsFieldNumber = 2;
  inline const ::std::string& patterns() const;
  inline void set_patterns(const ::std::string& value);
  inline void set_patterns(const char* value);
  inline void set_patterns(const char* value, size_t size);
  inline ::std::string* mutable_patterns();
  inline ::std::string* release_patterns();
  
  // required int64 awardMoney = 3;
  inline bool has_awardmoney() const;
  inline void clear_awardmoney();
  static const int kAwardMoneyFieldNumber = 3;
  inline ::google::protobuf::int64 awardmoney() const;
  inline void set_awardmoney(::google::protobuf::int64 value);
  
  // required int64 userMoney = 4;
  inline bool has_usermoney() const;
  inline void clear_usermoney();
  static const int kUserMoneyFieldNumber = 4;
  inline ::google::protobuf::int64 usermoney() const;
  inline void set_usermoney(::google::protobuf::int64 value);
  
  // optional int32 awardIndex = 5;
  inline bool has_awardindex() const;
  inline void clear_awardindex();
  static const int kAwardIndexFieldNumber = 5;
  inline ::google::protobuf::int32 awardindex() const;
  inline void set_awardindex(::google::protobuf::int32 value);
  
  // optional int32 playTimes = 6;
  inline bool has_playtimes() const;
  inline void clear_playtimes();
  static const int kPlayTimesFieldNumber = 6;
  inline ::google::protobuf::int32 playtimes() const;
  inline void set_playtimes(::google::protobuf::int32 value);
  
  // optional int32 doubleTimes = 7;
  inline bool has_doubletimes() const;
  inline void clear_doubletimes();
  static const int kDoubleTimesFieldNumber = 7;
  inline ::google::protobuf::int32 doubletimes() const;
  inline void set_doubletimes(::google::protobuf::int32 value);
  
  // required bool canBet = 8;
  inline bool has_canbet() const;
  inline void clear_canbet();
  static const int kCanBetFieldNumber = 8;
  inline bool canbet() const;
  inline void set_canbet(bool value);
  
  // required bool canDoubleBet = 9;
  inline bool has_candoublebet() const;
  inline void clear_candoublebet();
  static const int kCanDoubleBetFieldNumber = 9;
  inline bool candoublebet() const;
  inline void set_candoublebet(bool value);
  
  // required int32 count = 10;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 10;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ourgame.clown.msg.ackLotteryAward)
 private:
  inline void set_has_sessionid();
  inline void clear_has_sessionid();
  inline void set_has_patterns();
  inline void clear_has_patterns();
  inline void set_has_awardmoney();
  inline void clear_has_awardmoney();
  inline void set_has_usermoney();
  inline void clear_has_usermoney();
  inline void set_has_awardindex();
  inline void clear_has_awardindex();
  inline void set_has_playtimes();
  inline void clear_has_playtimes();
  inline void set_has_doubletimes();
  inline void clear_has_doubletimes();
  inline void set_has_canbet();
  inline void clear_has_canbet();
  inline void set_has_candoublebet();
  inline void clear_has_candoublebet();
  inline void set_has_count();
  inline void clear_has_count();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 sessionid_;
  ::std::string* patterns_;
  ::google::protobuf::int64 awardmoney_;
  ::google::protobuf::int64 usermoney_;
  ::google::protobuf::int32 awardindex_;
  ::google::protobuf::int32 playtimes_;
  ::google::protobuf::int32 doubletimes_;
  bool canbet_;
  bool candoublebet_;
  ::google::protobuf::int32 count_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];
  
  friend void  protobuf_AddDesc_ClownServerMessage_2eproto();
  friend void protobuf_AssignDesc_ClownServerMessage_2eproto();
  friend void protobuf_ShutdownFile_ClownServerMessage_2eproto();
  
  void InitAsDefaultInstance();
  static ackLotteryAward* default_instance_;
};
// -------------------------------------------------------------------

class ReqSendHorn : public ::google::protobuf::Message {
 public:
  ReqSendHorn();
  virtual ~ReqSendHorn();
  
  ReqSendHorn(const ReqSendHorn& from);
  
  inline ReqSendHorn& operator=(const ReqSendHorn& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqSendHorn& default_instance();
  
  void Swap(ReqSendHorn* other);
  
  // implements Message ----------------------------------------------
  
  ReqSendHorn* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqSendHorn& from);
  void MergeFrom(const ReqSendHorn& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string username = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  
  // optional string contents = 2;
  inline bool has_contents() const;
  inline void clear_contents();
  static const int kContentsFieldNumber = 2;
  inline const ::std::string& contents() const;
  inline void set_contents(const ::std::string& value);
  inline void set_contents(const char* value);
  inline void set_contents(const char* value, size_t size);
  inline ::std::string* mutable_contents();
  inline ::std::string* release_contents();
  
  // @@protoc_insertion_point(class_scope:com.ourgame.clown.msg.ReqSendHorn)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_contents();
  inline void clear_has_contents();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* username_;
  ::std::string* contents_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ClownServerMessage_2eproto();
  friend void protobuf_AssignDesc_ClownServerMessage_2eproto();
  friend void protobuf_ShutdownFile_ClownServerMessage_2eproto();
  
  void InitAsDefaultInstance();
  static ReqSendHorn* default_instance_;
};
// -------------------------------------------------------------------

class ReqBetFromOthers : public ::google::protobuf::Message {
 public:
  ReqBetFromOthers();
  virtual ~ReqBetFromOthers();
  
  ReqBetFromOthers(const ReqBetFromOthers& from);
  
  inline ReqBetFromOthers& operator=(const ReqBetFromOthers& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqBetFromOthers& default_instance();
  
  void Swap(ReqBetFromOthers* other);
  
  // implements Message ----------------------------------------------
  
  ReqBetFromOthers* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqBetFromOthers& from);
  void MergeFrom(const ReqBetFromOthers& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int64 sessionId = 1;
  inline bool has_sessionid() const;
  inline void clear_sessionid();
  static const int kSessionIdFieldNumber = 1;
  inline ::google::protobuf::int64 sessionid() const;
  inline void set_sessionid(::google::protobuf::int64 value);
  
  // required int32 betType = 2;
  inline bool has_bettype() const;
  inline void clear_bettype();
  static const int kBetTypeFieldNumber = 2;
  inline ::google::protobuf::int32 bettype() const;
  inline void set_bettype(::google::protobuf::int32 value);
  
  // required int64 ante = 3;
  inline bool has_ante() const;
  inline void clear_ante();
  static const int kAnteFieldNumber = 3;
  inline ::google::protobuf::int64 ante() const;
  inline void set_ante(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:com.ourgame.clown.msg.ReqBetFromOthers)
 private:
  inline void set_has_sessionid();
  inline void clear_has_sessionid();
  inline void set_has_bettype();
  inline void clear_has_bettype();
  inline void set_has_ante();
  inline void clear_has_ante();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 sessionid_;
  ::google::protobuf::int64 ante_;
  ::google::protobuf::int32 bettype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_ClownServerMessage_2eproto();
  friend void protobuf_AssignDesc_ClownServerMessage_2eproto();
  friend void protobuf_ShutdownFile_ClownServerMessage_2eproto();
  
  void InitAsDefaultInstance();
  static ReqBetFromOthers* default_instance_;
};
// -------------------------------------------------------------------

class ReqUserMoney : public ::google::protobuf::Message {
 public:
  ReqUserMoney();
  virtual ~ReqUserMoney();
  
  ReqUserMoney(const ReqUserMoney& from);
  
  inline ReqUserMoney& operator=(const ReqUserMoney& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqUserMoney& default_instance();
  
  void Swap(ReqUserMoney* other);
  
  // implements Message ----------------------------------------------
  
  ReqUserMoney* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqUserMoney& from);
  void MergeFrom(const ReqUserMoney& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string username = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  
  // @@protoc_insertion_point(class_scope:com.ourgame.clown.msg.ReqUserMoney)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* username_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_ClownServerMessage_2eproto();
  friend void protobuf_AssignDesc_ClownServerMessage_2eproto();
  friend void protobuf_ShutdownFile_ClownServerMessage_2eproto();
  
  void InitAsDefaultInstance();
  static ReqUserMoney* default_instance_;
};
// ===================================================================


// ===================================================================

// DuxLiveTick

// required int64 time = 1;
inline bool DuxLiveTick::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DuxLiveTick::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DuxLiveTick::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DuxLiveTick::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 DuxLiveTick::time() const {
  return time_;
}
inline void DuxLiveTick::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
}

// -------------------------------------------------------------------

// ReqLogin

// required string roleName = 1;
inline bool ReqLogin::has_rolename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqLogin::set_has_rolename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqLogin::clear_has_rolename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqLogin::clear_rolename() {
  if (rolename_ != &::google::protobuf::internal::kEmptyString) {
    rolename_->clear();
  }
  clear_has_rolename();
}
inline const ::std::string& ReqLogin::rolename() const {
  return *rolename_;
}
inline void ReqLogin::set_rolename(const ::std::string& value) {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  rolename_->assign(value);
}
inline void ReqLogin::set_rolename(const char* value) {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  rolename_->assign(value);
}
inline void ReqLogin::set_rolename(const char* value, size_t size) {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  rolename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqLogin::mutable_rolename() {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  return rolename_;
}
inline ::std::string* ReqLogin::release_rolename() {
  clear_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rolename_;
    rolename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int64 userId = 2;
inline bool ReqLogin::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqLogin::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqLogin::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqLogin::clear_userid() {
  userid_ = GOOGLE_LONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::int64 ReqLogin::userid() const {
  return userid_;
}
inline void ReqLogin::set_userid(::google::protobuf::int64 value) {
  set_has_userid();
  userid_ = value;
}

// required string userName = 3;
inline bool ReqLogin::has_username() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqLogin::set_has_username() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqLogin::clear_has_username() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqLogin::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& ReqLogin::username() const {
  return *username_;
}
inline void ReqLogin::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void ReqLogin::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void ReqLogin::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqLogin::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* ReqLogin::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string password = 4;
inline bool ReqLogin::has_password() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReqLogin::set_has_password() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReqLogin::clear_has_password() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReqLogin::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& ReqLogin::password() const {
  return *password_;
}
inline void ReqLogin::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void ReqLogin::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void ReqLogin::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqLogin::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* ReqLogin::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 fatherGameId = 5;
inline bool ReqLogin::has_fathergameid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReqLogin::set_has_fathergameid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReqLogin::clear_has_fathergameid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReqLogin::clear_fathergameid() {
  fathergameid_ = 0;
  clear_has_fathergameid();
}
inline ::google::protobuf::int32 ReqLogin::fathergameid() const {
  return fathergameid_;
}
inline void ReqLogin::set_fathergameid(::google::protobuf::int32 value) {
  set_has_fathergameid();
  fathergameid_ = value;
}

// optional string loaderURL = 6;
inline bool ReqLogin::has_loaderurl() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ReqLogin::set_has_loaderurl() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ReqLogin::clear_has_loaderurl() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ReqLogin::clear_loaderurl() {
  if (loaderurl_ != &::google::protobuf::internal::kEmptyString) {
    loaderurl_->clear();
  }
  clear_has_loaderurl();
}
inline const ::std::string& ReqLogin::loaderurl() const {
  return *loaderurl_;
}
inline void ReqLogin::set_loaderurl(const ::std::string& value) {
  set_has_loaderurl();
  if (loaderurl_ == &::google::protobuf::internal::kEmptyString) {
    loaderurl_ = new ::std::string;
  }
  loaderurl_->assign(value);
}
inline void ReqLogin::set_loaderurl(const char* value) {
  set_has_loaderurl();
  if (loaderurl_ == &::google::protobuf::internal::kEmptyString) {
    loaderurl_ = new ::std::string;
  }
  loaderurl_->assign(value);
}
inline void ReqLogin::set_loaderurl(const char* value, size_t size) {
  set_has_loaderurl();
  if (loaderurl_ == &::google::protobuf::internal::kEmptyString) {
    loaderurl_ = new ::std::string;
  }
  loaderurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqLogin::mutable_loaderurl() {
  set_has_loaderurl();
  if (loaderurl_ == &::google::protobuf::internal::kEmptyString) {
    loaderurl_ = new ::std::string;
  }
  return loaderurl_;
}
inline ::std::string* ReqLogin::release_loaderurl() {
  clear_has_loaderurl();
  if (loaderurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = loaderurl_;
    loaderurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool force = 7;
inline bool ReqLogin::has_force() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ReqLogin::set_has_force() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ReqLogin::clear_has_force() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ReqLogin::clear_force() {
  force_ = false;
  clear_has_force();
}
inline bool ReqLogin::force() const {
  return force_;
}
inline void ReqLogin::set_force(bool value) {
  set_has_force();
  force_ = value;
}

// optional string ticket = 8;
inline bool ReqLogin::has_ticket() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ReqLogin::set_has_ticket() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ReqLogin::clear_has_ticket() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ReqLogin::clear_ticket() {
  if (ticket_ != &::google::protobuf::internal::kEmptyString) {
    ticket_->clear();
  }
  clear_has_ticket();
}
inline const ::std::string& ReqLogin::ticket() const {
  return *ticket_;
}
inline void ReqLogin::set_ticket(const ::std::string& value) {
  set_has_ticket();
  if (ticket_ == &::google::protobuf::internal::kEmptyString) {
    ticket_ = new ::std::string;
  }
  ticket_->assign(value);
}
inline void ReqLogin::set_ticket(const char* value) {
  set_has_ticket();
  if (ticket_ == &::google::protobuf::internal::kEmptyString) {
    ticket_ = new ::std::string;
  }
  ticket_->assign(value);
}
inline void ReqLogin::set_ticket(const char* value, size_t size) {
  set_has_ticket();
  if (ticket_ == &::google::protobuf::internal::kEmptyString) {
    ticket_ = new ::std::string;
  }
  ticket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqLogin::mutable_ticket() {
  set_has_ticket();
  if (ticket_ == &::google::protobuf::internal::kEmptyString) {
    ticket_ = new ::std::string;
  }
  return ticket_;
}
inline ::std::string* ReqLogin::release_ticket() {
  clear_has_ticket();
  if (ticket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ticket_;
    ticket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint64 ipAddress = 9;
inline bool ReqLogin::has_ipaddress() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ReqLogin::set_has_ipaddress() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ReqLogin::clear_has_ipaddress() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ReqLogin::clear_ipaddress() {
  ipaddress_ = GOOGLE_ULONGLONG(0);
  clear_has_ipaddress();
}
inline ::google::protobuf::uint64 ReqLogin::ipaddress() const {
  return ipaddress_;
}
inline void ReqLogin::set_ipaddress(::google::protobuf::uint64 value) {
  set_has_ipaddress();
  ipaddress_ = value;
}

// optional uint32 gameId = 10;
inline bool ReqLogin::has_gameid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ReqLogin::set_has_gameid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ReqLogin::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ReqLogin::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 ReqLogin::gameid() const {
  return gameid_;
}
inline void ReqLogin::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// optional uint32 moneyType = 11;
inline bool ReqLogin::has_moneytype() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ReqLogin::set_has_moneytype() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ReqLogin::clear_has_moneytype() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ReqLogin::clear_moneytype() {
  moneytype_ = 0u;
  clear_has_moneytype();
}
inline ::google::protobuf::uint32 ReqLogin::moneytype() const {
  return moneytype_;
}
inline void ReqLogin::set_moneytype(::google::protobuf::uint32 value) {
  set_has_moneytype();
  moneytype_ = value;
}

// -------------------------------------------------------------------

// AckLogin

// required int64 sessionId = 1;
inline bool AckLogin::has_sessionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckLogin::set_has_sessionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckLogin::clear_has_sessionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckLogin::clear_sessionid() {
  sessionid_ = GOOGLE_LONGLONG(0);
  clear_has_sessionid();
}
inline ::google::protobuf::int64 AckLogin::sessionid() const {
  return sessionid_;
}
inline void AckLogin::set_sessionid(::google::protobuf::int64 value) {
  set_has_sessionid();
  sessionid_ = value;
}

// required int32 success = 2;
inline bool AckLogin::has_success() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckLogin::set_has_success() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckLogin::clear_has_success() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckLogin::clear_success() {
  success_ = 0;
  clear_has_success();
}
inline ::google::protobuf::int32 AckLogin::success() const {
  return success_;
}
inline void AckLogin::set_success(::google::protobuf::int32 value) {
  set_has_success();
  success_ = value;
}

// optional string failReason = 3;
inline bool AckLogin::has_failreason() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckLogin::set_has_failreason() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckLogin::clear_has_failreason() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckLogin::clear_failreason() {
  if (failreason_ != &::google::protobuf::internal::kEmptyString) {
    failreason_->clear();
  }
  clear_has_failreason();
}
inline const ::std::string& AckLogin::failreason() const {
  return *failreason_;
}
inline void AckLogin::set_failreason(const ::std::string& value) {
  set_has_failreason();
  if (failreason_ == &::google::protobuf::internal::kEmptyString) {
    failreason_ = new ::std::string;
  }
  failreason_->assign(value);
}
inline void AckLogin::set_failreason(const char* value) {
  set_has_failreason();
  if (failreason_ == &::google::protobuf::internal::kEmptyString) {
    failreason_ = new ::std::string;
  }
  failreason_->assign(value);
}
inline void AckLogin::set_failreason(const char* value, size_t size) {
  set_has_failreason();
  if (failreason_ == &::google::protobuf::internal::kEmptyString) {
    failreason_ = new ::std::string;
  }
  failreason_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckLogin::mutable_failreason() {
  set_has_failreason();
  if (failreason_ == &::google::protobuf::internal::kEmptyString) {
    failreason_ = new ::std::string;
  }
  return failreason_;
}
inline ::std::string* AckLogin::release_failreason() {
  clear_has_failreason();
  if (failreason_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = failreason_;
    failreason_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int64 userId = 4;
inline bool AckLogin::has_userid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AckLogin::set_has_userid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AckLogin::clear_has_userid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AckLogin::clear_userid() {
  userid_ = GOOGLE_LONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::int64 AckLogin::userid() const {
  return userid_;
}
inline void AckLogin::set_userid(::google::protobuf::int64 value) {
  set_has_userid();
  userid_ = value;
}

// optional string username = 5;
inline bool AckLogin::has_username() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AckLogin::set_has_username() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AckLogin::clear_has_username() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AckLogin::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& AckLogin::username() const {
  return *username_;
}
inline void AckLogin::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void AckLogin::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void AckLogin::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckLogin::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* AckLogin::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int64 userMoney = 6;
inline bool AckLogin::has_usermoney() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AckLogin::set_has_usermoney() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AckLogin::clear_has_usermoney() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AckLogin::clear_usermoney() {
  usermoney_ = GOOGLE_LONGLONG(0);
  clear_has_usermoney();
}
inline ::google::protobuf::int64 AckLogin::usermoney() const {
  return usermoney_;
}
inline void AckLogin::set_usermoney(::google::protobuf::int64 value) {
  set_has_usermoney();
  usermoney_ = value;
}

// optional int32 playTimes = 7;
inline bool AckLogin::has_playtimes() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AckLogin::set_has_playtimes() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AckLogin::clear_has_playtimes() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AckLogin::clear_playtimes() {
  playtimes_ = 0;
  clear_has_playtimes();
}
inline ::google::protobuf::int32 AckLogin::playtimes() const {
  return playtimes_;
}
inline void AckLogin::set_playtimes(::google::protobuf::int32 value) {
  set_has_playtimes();
  playtimes_ = value;
}

// optional int32 doubleTimes = 8;
inline bool AckLogin::has_doubletimes() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AckLogin::set_has_doubletimes() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AckLogin::clear_has_doubletimes() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AckLogin::clear_doubletimes() {
  doubletimes_ = 0;
  clear_has_doubletimes();
}
inline ::google::protobuf::int32 AckLogin::doubletimes() const {
  return doubletimes_;
}
inline void AckLogin::set_doubletimes(::google::protobuf::int32 value) {
  set_has_doubletimes();
  doubletimes_ = value;
}

// optional int32 is_guide = 9;
inline bool AckLogin::has_is_guide() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AckLogin::set_has_is_guide() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AckLogin::clear_has_is_guide() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AckLogin::clear_is_guide() {
  is_guide_ = 0;
  clear_has_is_guide();
}
inline ::google::protobuf::int32 AckLogin::is_guide() const {
  return is_guide_;
}
inline void AckLogin::set_is_guide(::google::protobuf::int32 value) {
  set_has_is_guide();
  is_guide_ = value;
}

// -------------------------------------------------------------------

// ReqChipIn

// required int64 sessionId = 1;
inline bool ReqChipIn::has_sessionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqChipIn::set_has_sessionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqChipIn::clear_has_sessionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqChipIn::clear_sessionid() {
  sessionid_ = GOOGLE_LONGLONG(0);
  clear_has_sessionid();
}
inline ::google::protobuf::int64 ReqChipIn::sessionid() const {
  return sessionid_;
}
inline void ReqChipIn::set_sessionid(::google::protobuf::int64 value) {
  set_has_sessionid();
  sessionid_ = value;
}

// required int64 ante = 2;
inline bool ReqChipIn::has_ante() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqChipIn::set_has_ante() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqChipIn::clear_has_ante() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqChipIn::clear_ante() {
  ante_ = GOOGLE_LONGLONG(0);
  clear_has_ante();
}
inline ::google::protobuf::int64 ReqChipIn::ante() const {
  return ante_;
}
inline void ReqChipIn::set_ante(::google::protobuf::int64 value) {
  set_has_ante();
  ante_ = value;
}

// optional bool useDouble = 3;
inline bool ReqChipIn::has_usedouble() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqChipIn::set_has_usedouble() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqChipIn::clear_has_usedouble() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqChipIn::clear_usedouble() {
  usedouble_ = false;
  clear_has_usedouble();
}
inline bool ReqChipIn::usedouble() const {
  return usedouble_;
}
inline void ReqChipIn::set_usedouble(bool value) {
  set_has_usedouble();
  usedouble_ = value;
}

// -------------------------------------------------------------------

// AckChipInResult

// required int64 sessionId = 1;
inline bool AckChipInResult::has_sessionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckChipInResult::set_has_sessionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckChipInResult::clear_has_sessionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckChipInResult::clear_sessionid() {
  sessionid_ = GOOGLE_LONGLONG(0);
  clear_has_sessionid();
}
inline ::google::protobuf::int64 AckChipInResult::sessionid() const {
  return sessionid_;
}
inline void AckChipInResult::set_sessionid(::google::protobuf::int64 value) {
  set_has_sessionid();
  sessionid_ = value;
}

// required string patterns = 2;
inline bool AckChipInResult::has_patterns() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckChipInResult::set_has_patterns() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckChipInResult::clear_has_patterns() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckChipInResult::clear_patterns() {
  if (patterns_ != &::google::protobuf::internal::kEmptyString) {
    patterns_->clear();
  }
  clear_has_patterns();
}
inline const ::std::string& AckChipInResult::patterns() const {
  return *patterns_;
}
inline void AckChipInResult::set_patterns(const ::std::string& value) {
  set_has_patterns();
  if (patterns_ == &::google::protobuf::internal::kEmptyString) {
    patterns_ = new ::std::string;
  }
  patterns_->assign(value);
}
inline void AckChipInResult::set_patterns(const char* value) {
  set_has_patterns();
  if (patterns_ == &::google::protobuf::internal::kEmptyString) {
    patterns_ = new ::std::string;
  }
  patterns_->assign(value);
}
inline void AckChipInResult::set_patterns(const char* value, size_t size) {
  set_has_patterns();
  if (patterns_ == &::google::protobuf::internal::kEmptyString) {
    patterns_ = new ::std::string;
  }
  patterns_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckChipInResult::mutable_patterns() {
  set_has_patterns();
  if (patterns_ == &::google::protobuf::internal::kEmptyString) {
    patterns_ = new ::std::string;
  }
  return patterns_;
}
inline ::std::string* AckChipInResult::release_patterns() {
  clear_has_patterns();
  if (patterns_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = patterns_;
    patterns_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int64 awardMoney = 3;
inline bool AckChipInResult::has_awardmoney() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckChipInResult::set_has_awardmoney() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckChipInResult::clear_has_awardmoney() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckChipInResult::clear_awardmoney() {
  awardmoney_ = GOOGLE_LONGLONG(0);
  clear_has_awardmoney();
}
inline ::google::protobuf::int64 AckChipInResult::awardmoney() const {
  return awardmoney_;
}
inline void AckChipInResult::set_awardmoney(::google::protobuf::int64 value) {
  set_has_awardmoney();
  awardmoney_ = value;
}

// required int64 userMoney = 4;
inline bool AckChipInResult::has_usermoney() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AckChipInResult::set_has_usermoney() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AckChipInResult::clear_has_usermoney() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AckChipInResult::clear_usermoney() {
  usermoney_ = GOOGLE_LONGLONG(0);
  clear_has_usermoney();
}
inline ::google::protobuf::int64 AckChipInResult::usermoney() const {
  return usermoney_;
}
inline void AckChipInResult::set_usermoney(::google::protobuf::int64 value) {
  set_has_usermoney();
  usermoney_ = value;
}

// optional int32 awardIndex = 5;
inline bool AckChipInResult::has_awardindex() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AckChipInResult::set_has_awardindex() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AckChipInResult::clear_has_awardindex() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AckChipInResult::clear_awardindex() {
  awardindex_ = 0;
  clear_has_awardindex();
}
inline ::google::protobuf::int32 AckChipInResult::awardindex() const {
  return awardindex_;
}
inline void AckChipInResult::set_awardindex(::google::protobuf::int32 value) {
  set_has_awardindex();
  awardindex_ = value;
}

// optional int32 playTimes = 6;
inline bool AckChipInResult::has_playtimes() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AckChipInResult::set_has_playtimes() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AckChipInResult::clear_has_playtimes() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AckChipInResult::clear_playtimes() {
  playtimes_ = 0;
  clear_has_playtimes();
}
inline ::google::protobuf::int32 AckChipInResult::playtimes() const {
  return playtimes_;
}
inline void AckChipInResult::set_playtimes(::google::protobuf::int32 value) {
  set_has_playtimes();
  playtimes_ = value;
}

// optional int32 doubleTimes = 7;
inline bool AckChipInResult::has_doubletimes() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AckChipInResult::set_has_doubletimes() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AckChipInResult::clear_has_doubletimes() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AckChipInResult::clear_doubletimes() {
  doubletimes_ = 0;
  clear_has_doubletimes();
}
inline ::google::protobuf::int32 AckChipInResult::doubletimes() const {
  return doubletimes_;
}
inline void AckChipInResult::set_doubletimes(::google::protobuf::int32 value) {
  set_has_doubletimes();
  doubletimes_ = value;
}

// required bool canBet = 8;
inline bool AckChipInResult::has_canbet() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AckChipInResult::set_has_canbet() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AckChipInResult::clear_has_canbet() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AckChipInResult::clear_canbet() {
  canbet_ = false;
  clear_has_canbet();
}
inline bool AckChipInResult::canbet() const {
  return canbet_;
}
inline void AckChipInResult::set_canbet(bool value) {
  set_has_canbet();
  canbet_ = value;
}

// required bool canDoubleBet = 9;
inline bool AckChipInResult::has_candoublebet() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AckChipInResult::set_has_candoublebet() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AckChipInResult::clear_has_candoublebet() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AckChipInResult::clear_candoublebet() {
  candoublebet_ = false;
  clear_has_candoublebet();
}
inline bool AckChipInResult::candoublebet() const {
  return candoublebet_;
}
inline void AckChipInResult::set_candoublebet(bool value) {
  set_has_candoublebet();
  candoublebet_ = value;
}

// -------------------------------------------------------------------

// ReqCharge

// required int64 sessionId = 1;
inline bool ReqCharge::has_sessionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqCharge::set_has_sessionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqCharge::clear_has_sessionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqCharge::clear_sessionid() {
  sessionid_ = GOOGLE_LONGLONG(0);
  clear_has_sessionid();
}
inline ::google::protobuf::int64 ReqCharge::sessionid() const {
  return sessionid_;
}
inline void ReqCharge::set_sessionid(::google::protobuf::int64 value) {
  set_has_sessionid();
  sessionid_ = value;
}

// -------------------------------------------------------------------

// AckCharge

// required int64 sessionId = 1;
inline bool AckCharge::has_sessionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckCharge::set_has_sessionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckCharge::clear_has_sessionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckCharge::clear_sessionid() {
  sessionid_ = GOOGLE_LONGLONG(0);
  clear_has_sessionid();
}
inline ::google::protobuf::int64 AckCharge::sessionid() const {
  return sessionid_;
}
inline void AckCharge::set_sessionid(::google::protobuf::int64 value) {
  set_has_sessionid();
  sessionid_ = value;
}

// required bool success = 2;
inline bool AckCharge::has_success() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckCharge::set_has_success() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckCharge::clear_has_success() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckCharge::clear_success() {
  success_ = false;
  clear_has_success();
}
inline bool AckCharge::success() const {
  return success_;
}
inline void AckCharge::set_success(bool value) {
  set_has_success();
  success_ = value;
}

// required int64 userMoney = 3;
inline bool AckCharge::has_usermoney() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckCharge::set_has_usermoney() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckCharge::clear_has_usermoney() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckCharge::clear_usermoney() {
  usermoney_ = GOOGLE_LONGLONG(0);
  clear_has_usermoney();
}
inline ::google::protobuf::int64 AckCharge::usermoney() const {
  return usermoney_;
}
inline void AckCharge::set_usermoney(::google::protobuf::int64 value) {
  set_has_usermoney();
  usermoney_ = value;
}

// optional int64 extraAward = 4;
inline bool AckCharge::has_extraaward() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AckCharge::set_has_extraaward() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AckCharge::clear_has_extraaward() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AckCharge::clear_extraaward() {
  extraaward_ = GOOGLE_LONGLONG(0);
  clear_has_extraaward();
}
inline ::google::protobuf::int64 AckCharge::extraaward() const {
  return extraaward_;
}
inline void AckCharge::set_extraaward(::google::protobuf::int64 value) {
  set_has_extraaward();
  extraaward_ = value;
}

// optional int32 persent = 5;
inline bool AckCharge::has_persent() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AckCharge::set_has_persent() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AckCharge::clear_has_persent() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AckCharge::clear_persent() {
  persent_ = 0;
  clear_has_persent();
}
inline ::google::protobuf::int32 AckCharge::persent() const {
  return persent_;
}
inline void AckCharge::set_persent(::google::protobuf::int32 value) {
  set_has_persent();
  persent_ = value;
}

// -------------------------------------------------------------------

// AckEntityAward

// required uint32 id = 1;
inline bool AckEntityAward::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckEntityAward::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckEntityAward::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckEntityAward::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 AckEntityAward::id() const {
  return id_;
}
inline void AckEntityAward::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// required uint32 amount = 2;
inline bool AckEntityAward::has_amount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckEntityAward::set_has_amount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckEntityAward::clear_has_amount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckEntityAward::clear_amount() {
  amount_ = 0u;
  clear_has_amount();
}
inline ::google::protobuf::uint32 AckEntityAward::amount() const {
  return amount_;
}
inline void AckEntityAward::set_amount(::google::protobuf::uint32 value) {
  set_has_amount();
  amount_ = value;
}

// required string name = 3;
inline bool AckEntityAward::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckEntityAward::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckEntityAward::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckEntityAward::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& AckEntityAward::name() const {
  return *name_;
}
inline void AckEntityAward::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AckEntityAward::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AckEntityAward::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckEntityAward::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* AckEntityAward::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string unit = 4;
inline bool AckEntityAward::has_unit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AckEntityAward::set_has_unit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AckEntityAward::clear_has_unit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AckEntityAward::clear_unit() {
  if (unit_ != &::google::protobuf::internal::kEmptyString) {
    unit_->clear();
  }
  clear_has_unit();
}
inline const ::std::string& AckEntityAward::unit() const {
  return *unit_;
}
inline void AckEntityAward::set_unit(const ::std::string& value) {
  set_has_unit();
  if (unit_ == &::google::protobuf::internal::kEmptyString) {
    unit_ = new ::std::string;
  }
  unit_->assign(value);
}
inline void AckEntityAward::set_unit(const char* value) {
  set_has_unit();
  if (unit_ == &::google::protobuf::internal::kEmptyString) {
    unit_ = new ::std::string;
  }
  unit_->assign(value);
}
inline void AckEntityAward::set_unit(const char* value, size_t size) {
  set_has_unit();
  if (unit_ == &::google::protobuf::internal::kEmptyString) {
    unit_ = new ::std::string;
  }
  unit_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckEntityAward::mutable_unit() {
  set_has_unit();
  if (unit_ == &::google::protobuf::internal::kEmptyString) {
    unit_ = new ::std::string;
  }
  return unit_;
}
inline ::std::string* AckEntityAward::release_unit() {
  clear_has_unit();
  if (unit_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = unit_;
    unit_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string url = 5;
inline bool AckEntityAward::has_url() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AckEntityAward::set_has_url() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AckEntityAward::clear_has_url() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AckEntityAward::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& AckEntityAward::url() const {
  return *url_;
}
inline void AckEntityAward::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void AckEntityAward::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void AckEntityAward::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckEntityAward::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* AckEntityAward::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ReqFillUserInfo

// required string realName = 1;
inline bool ReqFillUserInfo::has_realname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqFillUserInfo::set_has_realname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqFillUserInfo::clear_has_realname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqFillUserInfo::clear_realname() {
  if (realname_ != &::google::protobuf::internal::kEmptyString) {
    realname_->clear();
  }
  clear_has_realname();
}
inline const ::std::string& ReqFillUserInfo::realname() const {
  return *realname_;
}
inline void ReqFillUserInfo::set_realname(const ::std::string& value) {
  set_has_realname();
  if (realname_ == &::google::protobuf::internal::kEmptyString) {
    realname_ = new ::std::string;
  }
  realname_->assign(value);
}
inline void ReqFillUserInfo::set_realname(const char* value) {
  set_has_realname();
  if (realname_ == &::google::protobuf::internal::kEmptyString) {
    realname_ = new ::std::string;
  }
  realname_->assign(value);
}
inline void ReqFillUserInfo::set_realname(const char* value, size_t size) {
  set_has_realname();
  if (realname_ == &::google::protobuf::internal::kEmptyString) {
    realname_ = new ::std::string;
  }
  realname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqFillUserInfo::mutable_realname() {
  set_has_realname();
  if (realname_ == &::google::protobuf::internal::kEmptyString) {
    realname_ = new ::std::string;
  }
  return realname_;
}
inline ::std::string* ReqFillUserInfo::release_realname() {
  clear_has_realname();
  if (realname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = realname_;
    realname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string mobile = 2;
inline bool ReqFillUserInfo::has_mobile() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqFillUserInfo::set_has_mobile() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqFillUserInfo::clear_has_mobile() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqFillUserInfo::clear_mobile() {
  if (mobile_ != &::google::protobuf::internal::kEmptyString) {
    mobile_->clear();
  }
  clear_has_mobile();
}
inline const ::std::string& ReqFillUserInfo::mobile() const {
  return *mobile_;
}
inline void ReqFillUserInfo::set_mobile(const ::std::string& value) {
  set_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    mobile_ = new ::std::string;
  }
  mobile_->assign(value);
}
inline void ReqFillUserInfo::set_mobile(const char* value) {
  set_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    mobile_ = new ::std::string;
  }
  mobile_->assign(value);
}
inline void ReqFillUserInfo::set_mobile(const char* value, size_t size) {
  set_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    mobile_ = new ::std::string;
  }
  mobile_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqFillUserInfo::mutable_mobile() {
  set_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    mobile_ = new ::std::string;
  }
  return mobile_;
}
inline ::std::string* ReqFillUserInfo::release_mobile() {
  clear_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mobile_;
    mobile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string address = 3;
inline bool ReqFillUserInfo::has_address() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqFillUserInfo::set_has_address() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqFillUserInfo::clear_has_address() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqFillUserInfo::clear_address() {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    address_->clear();
  }
  clear_has_address();
}
inline const ::std::string& ReqFillUserInfo::address() const {
  return *address_;
}
inline void ReqFillUserInfo::set_address(const ::std::string& value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void ReqFillUserInfo::set_address(const char* value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void ReqFillUserInfo::set_address(const char* value, size_t size) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqFillUserInfo::mutable_address() {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  return address_;
}
inline ::std::string* ReqFillUserInfo::release_address() {
  clear_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = address_;
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string zipCode = 4;
inline bool ReqFillUserInfo::has_zipcode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReqFillUserInfo::set_has_zipcode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReqFillUserInfo::clear_has_zipcode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReqFillUserInfo::clear_zipcode() {
  if (zipcode_ != &::google::protobuf::internal::kEmptyString) {
    zipcode_->clear();
  }
  clear_has_zipcode();
}
inline const ::std::string& ReqFillUserInfo::zipcode() const {
  return *zipcode_;
}
inline void ReqFillUserInfo::set_zipcode(const ::std::string& value) {
  set_has_zipcode();
  if (zipcode_ == &::google::protobuf::internal::kEmptyString) {
    zipcode_ = new ::std::string;
  }
  zipcode_->assign(value);
}
inline void ReqFillUserInfo::set_zipcode(const char* value) {
  set_has_zipcode();
  if (zipcode_ == &::google::protobuf::internal::kEmptyString) {
    zipcode_ = new ::std::string;
  }
  zipcode_->assign(value);
}
inline void ReqFillUserInfo::set_zipcode(const char* value, size_t size) {
  set_has_zipcode();
  if (zipcode_ == &::google::protobuf::internal::kEmptyString) {
    zipcode_ = new ::std::string;
  }
  zipcode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqFillUserInfo::mutable_zipcode() {
  set_has_zipcode();
  if (zipcode_ == &::google::protobuf::internal::kEmptyString) {
    zipcode_ = new ::std::string;
  }
  return zipcode_;
}
inline ::std::string* ReqFillUserInfo::release_zipcode() {
  clear_has_zipcode();
  if (zipcode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = zipcode_;
    zipcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string idcard = 5;
inline bool ReqFillUserInfo::has_idcard() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReqFillUserInfo::set_has_idcard() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReqFillUserInfo::clear_has_idcard() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReqFillUserInfo::clear_idcard() {
  if (idcard_ != &::google::protobuf::internal::kEmptyString) {
    idcard_->clear();
  }
  clear_has_idcard();
}
inline const ::std::string& ReqFillUserInfo::idcard() const {
  return *idcard_;
}
inline void ReqFillUserInfo::set_idcard(const ::std::string& value) {
  set_has_idcard();
  if (idcard_ == &::google::protobuf::internal::kEmptyString) {
    idcard_ = new ::std::string;
  }
  idcard_->assign(value);
}
inline void ReqFillUserInfo::set_idcard(const char* value) {
  set_has_idcard();
  if (idcard_ == &::google::protobuf::internal::kEmptyString) {
    idcard_ = new ::std::string;
  }
  idcard_->assign(value);
}
inline void ReqFillUserInfo::set_idcard(const char* value, size_t size) {
  set_has_idcard();
  if (idcard_ == &::google::protobuf::internal::kEmptyString) {
    idcard_ = new ::std::string;
  }
  idcard_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqFillUserInfo::mutable_idcard() {
  set_has_idcard();
  if (idcard_ == &::google::protobuf::internal::kEmptyString) {
    idcard_ = new ::std::string;
  }
  return idcard_;
}
inline ::std::string* ReqFillUserInfo::release_idcard() {
  clear_has_idcard();
  if (idcard_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = idcard_;
    idcard_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string areaCode = 6;
inline bool ReqFillUserInfo::has_areacode() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ReqFillUserInfo::set_has_areacode() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ReqFillUserInfo::clear_has_areacode() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ReqFillUserInfo::clear_areacode() {
  if (areacode_ != &::google::protobuf::internal::kEmptyString) {
    areacode_->clear();
  }
  clear_has_areacode();
}
inline const ::std::string& ReqFillUserInfo::areacode() const {
  return *areacode_;
}
inline void ReqFillUserInfo::set_areacode(const ::std::string& value) {
  set_has_areacode();
  if (areacode_ == &::google::protobuf::internal::kEmptyString) {
    areacode_ = new ::std::string;
  }
  areacode_->assign(value);
}
inline void ReqFillUserInfo::set_areacode(const char* value) {
  set_has_areacode();
  if (areacode_ == &::google::protobuf::internal::kEmptyString) {
    areacode_ = new ::std::string;
  }
  areacode_->assign(value);
}
inline void ReqFillUserInfo::set_areacode(const char* value, size_t size) {
  set_has_areacode();
  if (areacode_ == &::google::protobuf::internal::kEmptyString) {
    areacode_ = new ::std::string;
  }
  areacode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqFillUserInfo::mutable_areacode() {
  set_has_areacode();
  if (areacode_ == &::google::protobuf::internal::kEmptyString) {
    areacode_ = new ::std::string;
  }
  return areacode_;
}
inline ::std::string* ReqFillUserInfo::release_areacode() {
  clear_has_areacode();
  if (areacode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = areacode_;
    areacode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string phone = 7;
inline bool ReqFillUserInfo::has_phone() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ReqFillUserInfo::set_has_phone() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ReqFillUserInfo::clear_has_phone() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ReqFillUserInfo::clear_phone() {
  if (phone_ != &::google::protobuf::internal::kEmptyString) {
    phone_->clear();
  }
  clear_has_phone();
}
inline const ::std::string& ReqFillUserInfo::phone() const {
  return *phone_;
}
inline void ReqFillUserInfo::set_phone(const ::std::string& value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void ReqFillUserInfo::set_phone(const char* value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void ReqFillUserInfo::set_phone(const char* value, size_t size) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqFillUserInfo::mutable_phone() {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  return phone_;
}
inline ::std::string* ReqFillUserInfo::release_phone() {
  clear_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = phone_;
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string memo = 8;
inline bool ReqFillUserInfo::has_memo() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ReqFillUserInfo::set_has_memo() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ReqFillUserInfo::clear_has_memo() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ReqFillUserInfo::clear_memo() {
  if (memo_ != &::google::protobuf::internal::kEmptyString) {
    memo_->clear();
  }
  clear_has_memo();
}
inline const ::std::string& ReqFillUserInfo::memo() const {
  return *memo_;
}
inline void ReqFillUserInfo::set_memo(const ::std::string& value) {
  set_has_memo();
  if (memo_ == &::google::protobuf::internal::kEmptyString) {
    memo_ = new ::std::string;
  }
  memo_->assign(value);
}
inline void ReqFillUserInfo::set_memo(const char* value) {
  set_has_memo();
  if (memo_ == &::google::protobuf::internal::kEmptyString) {
    memo_ = new ::std::string;
  }
  memo_->assign(value);
}
inline void ReqFillUserInfo::set_memo(const char* value, size_t size) {
  set_has_memo();
  if (memo_ == &::google::protobuf::internal::kEmptyString) {
    memo_ = new ::std::string;
  }
  memo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqFillUserInfo::mutable_memo() {
  set_has_memo();
  if (memo_ == &::google::protobuf::internal::kEmptyString) {
    memo_ = new ::std::string;
  }
  return memo_;
}
inline ::std::string* ReqFillUserInfo::release_memo() {
  clear_has_memo();
  if (memo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = memo_;
    memo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AckFillUserInfo

// required int32 success = 1;
inline bool AckFillUserInfo::has_success() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckFillUserInfo::set_has_success() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckFillUserInfo::clear_has_success() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckFillUserInfo::clear_success() {
  success_ = 0;
  clear_has_success();
}
inline ::google::protobuf::int32 AckFillUserInfo::success() const {
  return success_;
}
inline void AckFillUserInfo::set_success(::google::protobuf::int32 value) {
  set_has_success();
  success_ = value;
}

// optional string failReson = 2;
inline bool AckFillUserInfo::has_failreson() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckFillUserInfo::set_has_failreson() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckFillUserInfo::clear_has_failreson() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckFillUserInfo::clear_failreson() {
  if (failreson_ != &::google::protobuf::internal::kEmptyString) {
    failreson_->clear();
  }
  clear_has_failreson();
}
inline const ::std::string& AckFillUserInfo::failreson() const {
  return *failreson_;
}
inline void AckFillUserInfo::set_failreson(const ::std::string& value) {
  set_has_failreson();
  if (failreson_ == &::google::protobuf::internal::kEmptyString) {
    failreson_ = new ::std::string;
  }
  failreson_->assign(value);
}
inline void AckFillUserInfo::set_failreson(const char* value) {
  set_has_failreson();
  if (failreson_ == &::google::protobuf::internal::kEmptyString) {
    failreson_ = new ::std::string;
  }
  failreson_->assign(value);
}
inline void AckFillUserInfo::set_failreson(const char* value, size_t size) {
  set_has_failreson();
  if (failreson_ == &::google::protobuf::internal::kEmptyString) {
    failreson_ = new ::std::string;
  }
  failreson_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckFillUserInfo::mutable_failreson() {
  set_has_failreson();
  if (failreson_ == &::google::protobuf::internal::kEmptyString) {
    failreson_ = new ::std::string;
  }
  return failreson_;
}
inline ::std::string* AckFillUserInfo::release_failreson() {
  clear_has_failreson();
  if (failreson_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = failreson_;
    failreson_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// EntityAward

// required int32 id = 1;
inline bool EntityAward::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EntityAward::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EntityAward::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EntityAward::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 EntityAward::id() const {
  return id_;
}
inline void EntityAward::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required string nickname = 2;
inline bool EntityAward::has_nickname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EntityAward::set_has_nickname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EntityAward::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EntityAward::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& EntityAward::nickname() const {
  return *nickname_;
}
inline void EntityAward::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void EntityAward::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void EntityAward::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EntityAward::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  return nickname_;
}
inline ::std::string* EntityAward::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string date = 3;
inline bool EntityAward::has_date() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EntityAward::set_has_date() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EntityAward::clear_has_date() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EntityAward::clear_date() {
  if (date_ != &::google::protobuf::internal::kEmptyString) {
    date_->clear();
  }
  clear_has_date();
}
inline const ::std::string& EntityAward::date() const {
  return *date_;
}
inline void EntityAward::set_date(const ::std::string& value) {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  date_->assign(value);
}
inline void EntityAward::set_date(const char* value) {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  date_->assign(value);
}
inline void EntityAward::set_date(const char* value, size_t size) {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  date_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EntityAward::mutable_date() {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  return date_;
}
inline ::std::string* EntityAward::release_date() {
  clear_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = date_;
    date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required uint64 amount = 4;
inline bool EntityAward::has_amount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EntityAward::set_has_amount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EntityAward::clear_has_amount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EntityAward::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 EntityAward::amount() const {
  return amount_;
}
inline void EntityAward::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
}

// required string unit = 5;
inline bool EntityAward::has_unit() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EntityAward::set_has_unit() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EntityAward::clear_has_unit() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EntityAward::clear_unit() {
  if (unit_ != &::google::protobuf::internal::kEmptyString) {
    unit_->clear();
  }
  clear_has_unit();
}
inline const ::std::string& EntityAward::unit() const {
  return *unit_;
}
inline void EntityAward::set_unit(const ::std::string& value) {
  set_has_unit();
  if (unit_ == &::google::protobuf::internal::kEmptyString) {
    unit_ = new ::std::string;
  }
  unit_->assign(value);
}
inline void EntityAward::set_unit(const char* value) {
  set_has_unit();
  if (unit_ == &::google::protobuf::internal::kEmptyString) {
    unit_ = new ::std::string;
  }
  unit_->assign(value);
}
inline void EntityAward::set_unit(const char* value, size_t size) {
  set_has_unit();
  if (unit_ == &::google::protobuf::internal::kEmptyString) {
    unit_ = new ::std::string;
  }
  unit_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EntityAward::mutable_unit() {
  set_has_unit();
  if (unit_ == &::google::protobuf::internal::kEmptyString) {
    unit_ = new ::std::string;
  }
  return unit_;
}
inline ::std::string* EntityAward::release_unit() {
  clear_has_unit();
  if (unit_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = unit_;
    unit_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string name = 6;
inline bool EntityAward::has_name() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EntityAward::set_has_name() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EntityAward::clear_has_name() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EntityAward::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& EntityAward::name() const {
  return *name_;
}
inline void EntityAward::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void EntityAward::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void EntityAward::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EntityAward::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* EntityAward::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ReqActivityAwardList

// optional int32 page = 1 [default = 1];
inline bool ReqActivityAwardList::has_page() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqActivityAwardList::set_has_page() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqActivityAwardList::clear_has_page() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqActivityAwardList::clear_page() {
  page_ = 1;
  clear_has_page();
}
inline ::google::protobuf::int32 ReqActivityAwardList::page() const {
  return page_;
}
inline void ReqActivityAwardList::set_page(::google::protobuf::int32 value) {
  set_has_page();
  page_ = value;
}

// optional int32 size = 2 [default = 10];
inline bool ReqActivityAwardList::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqActivityAwardList::set_has_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqActivityAwardList::clear_has_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqActivityAwardList::clear_size() {
  size_ = 10;
  clear_has_size();
}
inline ::google::protobuf::int32 ReqActivityAwardList::size() const {
  return size_;
}
inline void ReqActivityAwardList::set_size(::google::protobuf::int32 value) {
  set_has_size();
  size_ = value;
}

// -------------------------------------------------------------------

// AckActivityAwardList

// repeated .com.ourgame.clown.msg.EntityAward awardList = 1;
inline int AckActivityAwardList::awardlist_size() const {
  return awardlist_.size();
}
inline void AckActivityAwardList::clear_awardlist() {
  awardlist_.Clear();
}
inline const ::com::ourgame::clown::msg::EntityAward& AckActivityAwardList::awardlist(int index) const {
  return awardlist_.Get(index);
}
inline ::com::ourgame::clown::msg::EntityAward* AckActivityAwardList::mutable_awardlist(int index) {
  return awardlist_.Mutable(index);
}
inline ::com::ourgame::clown::msg::EntityAward* AckActivityAwardList::add_awardlist() {
  return awardlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::ourgame::clown::msg::EntityAward >&
AckActivityAwardList::awardlist() const {
  return awardlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::ourgame::clown::msg::EntityAward >*
AckActivityAwardList::mutable_awardlist() {
  return &awardlist_;
}

// -------------------------------------------------------------------

// ReqEntityAwardHistory

// optional int32 page = 1 [default = 1];
inline bool ReqEntityAwardHistory::has_page() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqEntityAwardHistory::set_has_page() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqEntityAwardHistory::clear_has_page() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqEntityAwardHistory::clear_page() {
  page_ = 1;
  clear_has_page();
}
inline ::google::protobuf::int32 ReqEntityAwardHistory::page() const {
  return page_;
}
inline void ReqEntityAwardHistory::set_page(::google::protobuf::int32 value) {
  set_has_page();
  page_ = value;
}

// optional int32 size = 2 [default = 10];
inline bool ReqEntityAwardHistory::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqEntityAwardHistory::set_has_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqEntityAwardHistory::clear_has_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqEntityAwardHistory::clear_size() {
  size_ = 10;
  clear_has_size();
}
inline ::google::protobuf::int32 ReqEntityAwardHistory::size() const {
  return size_;
}
inline void ReqEntityAwardHistory::set_size(::google::protobuf::int32 value) {
  set_has_size();
  size_ = value;
}

// -------------------------------------------------------------------

// AckEntityAwardHistory

// repeated .com.ourgame.clown.msg.EntityAward awardList = 1;
inline int AckEntityAwardHistory::awardlist_size() const {
  return awardlist_.size();
}
inline void AckEntityAwardHistory::clear_awardlist() {
  awardlist_.Clear();
}
inline const ::com::ourgame::clown::msg::EntityAward& AckEntityAwardHistory::awardlist(int index) const {
  return awardlist_.Get(index);
}
inline ::com::ourgame::clown::msg::EntityAward* AckEntityAwardHistory::mutable_awardlist(int index) {
  return awardlist_.Mutable(index);
}
inline ::com::ourgame::clown::msg::EntityAward* AckEntityAwardHistory::add_awardlist() {
  return awardlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::ourgame::clown::msg::EntityAward >&
AckEntityAwardHistory::awardlist() const {
  return awardlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::ourgame::clown::msg::EntityAward >*
AckEntityAwardHistory::mutable_awardlist() {
  return &awardlist_;
}

// -------------------------------------------------------------------

// ReqBet

// required int64 sessionId = 1;
inline bool ReqBet::has_sessionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqBet::set_has_sessionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqBet::clear_has_sessionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqBet::clear_sessionid() {
  sessionid_ = GOOGLE_LONGLONG(0);
  clear_has_sessionid();
}
inline ::google::protobuf::int64 ReqBet::sessionid() const {
  return sessionid_;
}
inline void ReqBet::set_sessionid(::google::protobuf::int64 value) {
  set_has_sessionid();
  sessionid_ = value;
}

// required int32 betType = 2;
inline bool ReqBet::has_bettype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqBet::set_has_bettype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqBet::clear_has_bettype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqBet::clear_bettype() {
  bettype_ = 0;
  clear_has_bettype();
}
inline ::google::protobuf::int32 ReqBet::bettype() const {
  return bettype_;
}
inline void ReqBet::set_bettype(::google::protobuf::int32 value) {
  set_has_bettype();
  bettype_ = value;
}

// -------------------------------------------------------------------

// AckBet

// required int64 sessionId = 1;
inline bool AckBet::has_sessionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckBet::set_has_sessionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckBet::clear_has_sessionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckBet::clear_sessionid() {
  sessionid_ = GOOGLE_LONGLONG(0);
  clear_has_sessionid();
}
inline ::google::protobuf::int64 AckBet::sessionid() const {
  return sessionid_;
}
inline void AckBet::set_sessionid(::google::protobuf::int64 value) {
  set_has_sessionid();
  sessionid_ = value;
}

// required int32 betResult = 2;
inline bool AckBet::has_betresult() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckBet::set_has_betresult() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckBet::clear_has_betresult() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckBet::clear_betresult() {
  betresult_ = 0;
  clear_has_betresult();
}
inline ::google::protobuf::int32 AckBet::betresult() const {
  return betresult_;
}
inline void AckBet::set_betresult(::google::protobuf::int32 value) {
  set_has_betresult();
  betresult_ = value;
}

// required int64 awardMoney = 3;
inline bool AckBet::has_awardmoney() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckBet::set_has_awardmoney() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckBet::clear_has_awardmoney() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckBet::clear_awardmoney() {
  awardmoney_ = GOOGLE_LONGLONG(0);
  clear_has_awardmoney();
}
inline ::google::protobuf::int64 AckBet::awardmoney() const {
  return awardmoney_;
}
inline void AckBet::set_awardmoney(::google::protobuf::int64 value) {
  set_has_awardmoney();
  awardmoney_ = value;
}

// required int64 baseAnte = 4;
inline bool AckBet::has_baseante() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AckBet::set_has_baseante() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AckBet::clear_has_baseante() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AckBet::clear_baseante() {
  baseante_ = GOOGLE_LONGLONG(0);
  clear_has_baseante();
}
inline ::google::protobuf::int64 AckBet::baseante() const {
  return baseante_;
}
inline void AckBet::set_baseante(::google::protobuf::int64 value) {
  set_has_baseante();
  baseante_ = value;
}

// required int32 betTimes = 5;
inline bool AckBet::has_bettimes() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AckBet::set_has_bettimes() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AckBet::clear_has_bettimes() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AckBet::clear_bettimes() {
  bettimes_ = 0;
  clear_has_bettimes();
}
inline ::google::protobuf::int32 AckBet::bettimes() const {
  return bettimes_;
}
inline void AckBet::set_bettimes(::google::protobuf::int32 value) {
  set_has_bettimes();
  bettimes_ = value;
}

// required int64 userMoney = 6;
inline bool AckBet::has_usermoney() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AckBet::set_has_usermoney() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AckBet::clear_has_usermoney() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AckBet::clear_usermoney() {
  usermoney_ = GOOGLE_LONGLONG(0);
  clear_has_usermoney();
}
inline ::google::protobuf::int64 AckBet::usermoney() const {
  return usermoney_;
}
inline void AckBet::set_usermoney(::google::protobuf::int64 value) {
  set_has_usermoney();
  usermoney_ = value;
}

// optional int32 nextMultiple = 7;
inline bool AckBet::has_nextmultiple() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AckBet::set_has_nextmultiple() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AckBet::clear_has_nextmultiple() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AckBet::clear_nextmultiple() {
  nextmultiple_ = 0;
  clear_has_nextmultiple();
}
inline ::google::protobuf::int32 AckBet::nextmultiple() const {
  return nextmultiple_;
}
inline void AckBet::set_nextmultiple(::google::protobuf::int32 value) {
  set_has_nextmultiple();
  nextmultiple_ = value;
}

// required bool canBet = 8;
inline bool AckBet::has_canbet() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AckBet::set_has_canbet() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AckBet::clear_has_canbet() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AckBet::clear_canbet() {
  canbet_ = false;
  clear_has_canbet();
}
inline bool AckBet::canbet() const {
  return canbet_;
}
inline void AckBet::set_canbet(bool value) {
  set_has_canbet();
  canbet_ = value;
}

// required bool canDoubleBet = 9;
inline bool AckBet::has_candoublebet() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AckBet::set_has_candoublebet() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AckBet::clear_has_candoublebet() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AckBet::clear_candoublebet() {
  candoublebet_ = false;
  clear_has_candoublebet();
}
inline bool AckBet::candoublebet() const {
  return candoublebet_;
}
inline void AckBet::set_candoublebet(bool value) {
  set_has_candoublebet();
  candoublebet_ = value;
}

// optional string tipMessage = 10;
inline bool AckBet::has_tipmessage() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AckBet::set_has_tipmessage() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AckBet::clear_has_tipmessage() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AckBet::clear_tipmessage() {
  if (tipmessage_ != &::google::protobuf::internal::kEmptyString) {
    tipmessage_->clear();
  }
  clear_has_tipmessage();
}
inline const ::std::string& AckBet::tipmessage() const {
  return *tipmessage_;
}
inline void AckBet::set_tipmessage(const ::std::string& value) {
  set_has_tipmessage();
  if (tipmessage_ == &::google::protobuf::internal::kEmptyString) {
    tipmessage_ = new ::std::string;
  }
  tipmessage_->assign(value);
}
inline void AckBet::set_tipmessage(const char* value) {
  set_has_tipmessage();
  if (tipmessage_ == &::google::protobuf::internal::kEmptyString) {
    tipmessage_ = new ::std::string;
  }
  tipmessage_->assign(value);
}
inline void AckBet::set_tipmessage(const char* value, size_t size) {
  set_has_tipmessage();
  if (tipmessage_ == &::google::protobuf::internal::kEmptyString) {
    tipmessage_ = new ::std::string;
  }
  tipmessage_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckBet::mutable_tipmessage() {
  set_has_tipmessage();
  if (tipmessage_ == &::google::protobuf::internal::kEmptyString) {
    tipmessage_ = new ::std::string;
  }
  return tipmessage_;
}
inline ::std::string* AckBet::release_tipmessage() {
  clear_has_tipmessage();
  if (tipmessage_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tipmessage_;
    tipmessage_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AckTipMessage

// required int64 sessionId = 1;
inline bool AckTipMessage::has_sessionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckTipMessage::set_has_sessionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckTipMessage::clear_has_sessionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckTipMessage::clear_sessionid() {
  sessionid_ = GOOGLE_LONGLONG(0);
  clear_has_sessionid();
}
inline ::google::protobuf::int64 AckTipMessage::sessionid() const {
  return sessionid_;
}
inline void AckTipMessage::set_sessionid(::google::protobuf::int64 value) {
  set_has_sessionid();
  sessionid_ = value;
}

// required int32 msgType = 2;
inline bool AckTipMessage::has_msgtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckTipMessage::set_has_msgtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckTipMessage::clear_has_msgtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckTipMessage::clear_msgtype() {
  msgtype_ = 0;
  clear_has_msgtype();
}
inline ::google::protobuf::int32 AckTipMessage::msgtype() const {
  return msgtype_;
}
inline void AckTipMessage::set_msgtype(::google::protobuf::int32 value) {
  set_has_msgtype();
  msgtype_ = value;
}

// required string txtMsg = 3;
inline bool AckTipMessage::has_txtmsg() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckTipMessage::set_has_txtmsg() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckTipMessage::clear_has_txtmsg() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckTipMessage::clear_txtmsg() {
  if (txtmsg_ != &::google::protobuf::internal::kEmptyString) {
    txtmsg_->clear();
  }
  clear_has_txtmsg();
}
inline const ::std::string& AckTipMessage::txtmsg() const {
  return *txtmsg_;
}
inline void AckTipMessage::set_txtmsg(const ::std::string& value) {
  set_has_txtmsg();
  if (txtmsg_ == &::google::protobuf::internal::kEmptyString) {
    txtmsg_ = new ::std::string;
  }
  txtmsg_->assign(value);
}
inline void AckTipMessage::set_txtmsg(const char* value) {
  set_has_txtmsg();
  if (txtmsg_ == &::google::protobuf::internal::kEmptyString) {
    txtmsg_ = new ::std::string;
  }
  txtmsg_->assign(value);
}
inline void AckTipMessage::set_txtmsg(const char* value, size_t size) {
  set_has_txtmsg();
  if (txtmsg_ == &::google::protobuf::internal::kEmptyString) {
    txtmsg_ = new ::std::string;
  }
  txtmsg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckTipMessage::mutable_txtmsg() {
  set_has_txtmsg();
  if (txtmsg_ == &::google::protobuf::internal::kEmptyString) {
    txtmsg_ = new ::std::string;
  }
  return txtmsg_;
}
inline ::std::string* AckTipMessage::release_txtmsg() {
  clear_has_txtmsg();
  if (txtmsg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = txtmsg_;
    txtmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AckHugeAward

// required string username = 1;
inline bool AckHugeAward::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckHugeAward::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckHugeAward::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckHugeAward::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& AckHugeAward::username() const {
  return *username_;
}
inline void AckHugeAward::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void AckHugeAward::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void AckHugeAward::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckHugeAward::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* AckHugeAward::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int64 awardMoney = 2;
inline bool AckHugeAward::has_awardmoney() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckHugeAward::set_has_awardmoney() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckHugeAward::clear_has_awardmoney() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckHugeAward::clear_awardmoney() {
  awardmoney_ = GOOGLE_LONGLONG(0);
  clear_has_awardmoney();
}
inline ::google::protobuf::int64 AckHugeAward::awardmoney() const {
  return awardmoney_;
}
inline void AckHugeAward::set_awardmoney(::google::protobuf::int64 value) {
  set_has_awardmoney();
  awardmoney_ = value;
}

// required int64 awardTime = 3;
inline bool AckHugeAward::has_awardtime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckHugeAward::set_has_awardtime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckHugeAward::clear_has_awardtime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckHugeAward::clear_awardtime() {
  awardtime_ = GOOGLE_LONGLONG(0);
  clear_has_awardtime();
}
inline ::google::protobuf::int64 AckHugeAward::awardtime() const {
  return awardtime_;
}
inline void AckHugeAward::set_awardtime(::google::protobuf::int64 value) {
  set_has_awardtime();
  awardtime_ = value;
}

// -------------------------------------------------------------------

// AckDoubleChanceAward

// required int64 sessionId = 1;
inline bool AckDoubleChanceAward::has_sessionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckDoubleChanceAward::set_has_sessionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckDoubleChanceAward::clear_has_sessionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckDoubleChanceAward::clear_sessionid() {
  sessionid_ = GOOGLE_LONGLONG(0);
  clear_has_sessionid();
}
inline ::google::protobuf::int64 AckDoubleChanceAward::sessionid() const {
  return sessionid_;
}
inline void AckDoubleChanceAward::set_sessionid(::google::protobuf::int64 value) {
  set_has_sessionid();
  sessionid_ = value;
}

// required int32 chance = 2;
inline bool AckDoubleChanceAward::has_chance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckDoubleChanceAward::set_has_chance() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckDoubleChanceAward::clear_has_chance() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckDoubleChanceAward::clear_chance() {
  chance_ = 0;
  clear_has_chance();
}
inline ::google::protobuf::int32 AckDoubleChanceAward::chance() const {
  return chance_;
}
inline void AckDoubleChanceAward::set_chance(::google::protobuf::int32 value) {
  set_has_chance();
  chance_ = value;
}

// required int32 totalChance = 3;
inline bool AckDoubleChanceAward::has_totalchance() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckDoubleChanceAward::set_has_totalchance() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckDoubleChanceAward::clear_has_totalchance() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckDoubleChanceAward::clear_totalchance() {
  totalchance_ = 0;
  clear_has_totalchance();
}
inline ::google::protobuf::int32 AckDoubleChanceAward::totalchance() const {
  return totalchance_;
}
inline void AckDoubleChanceAward::set_totalchance(::google::protobuf::int32 value) {
  set_has_totalchance();
  totalchance_ = value;
}

// -------------------------------------------------------------------

// AckLoseTooMuch

// required int64 sessionId = 1;
inline bool AckLoseTooMuch::has_sessionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckLoseTooMuch::set_has_sessionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckLoseTooMuch::clear_has_sessionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckLoseTooMuch::clear_sessionid() {
  sessionid_ = GOOGLE_LONGLONG(0);
  clear_has_sessionid();
}
inline ::google::protobuf::int64 AckLoseTooMuch::sessionid() const {
  return sessionid_;
}
inline void AckLoseTooMuch::set_sessionid(::google::protobuf::int64 value) {
  set_has_sessionid();
  sessionid_ = value;
}

// -------------------------------------------------------------------

// AckCloseConnection

// required int64 sessionId = 1;
inline bool AckCloseConnection::has_sessionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckCloseConnection::set_has_sessionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckCloseConnection::clear_has_sessionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckCloseConnection::clear_sessionid() {
  sessionid_ = GOOGLE_LONGLONG(0);
  clear_has_sessionid();
}
inline ::google::protobuf::int64 AckCloseConnection::sessionid() const {
  return sessionid_;
}
inline void AckCloseConnection::set_sessionid(::google::protobuf::int64 value) {
  set_has_sessionid();
  sessionid_ = value;
}

// -------------------------------------------------------------------

// ReqOpenClown

// -------------------------------------------------------------------

// AckOpenClown

// required int32 result = 1;
inline bool AckOpenClown::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckOpenClown::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckOpenClown::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckOpenClown::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AckOpenClown::result() const {
  return result_;
}
inline void AckOpenClown::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional int64 freeMoney = 2;
inline bool AckOpenClown::has_freemoney() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckOpenClown::set_has_freemoney() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckOpenClown::clear_has_freemoney() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckOpenClown::clear_freemoney() {
  freemoney_ = GOOGLE_LONGLONG(0);
  clear_has_freemoney();
}
inline ::google::protobuf::int64 AckOpenClown::freemoney() const {
  return freemoney_;
}
inline void AckOpenClown::set_freemoney(::google::protobuf::int64 value) {
  set_has_freemoney();
  freemoney_ = value;
}

// optional int64 exchangeMoney = 3;
inline bool AckOpenClown::has_exchangemoney() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckOpenClown::set_has_exchangemoney() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckOpenClown::clear_has_exchangemoney() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckOpenClown::clear_exchangemoney() {
  exchangemoney_ = GOOGLE_LONGLONG(0);
  clear_has_exchangemoney();
}
inline ::google::protobuf::int64 AckOpenClown::exchangemoney() const {
  return exchangemoney_;
}
inline void AckOpenClown::set_exchangemoney(::google::protobuf::int64 value) {
  set_has_exchangemoney();
  exchangemoney_ = value;
}

// -------------------------------------------------------------------

// ReqCloseClown

// -------------------------------------------------------------------

// AckCloseClown

// required int32 result = 1;
inline bool AckCloseClown::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckCloseClown::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckCloseClown::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckCloseClown::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AckCloseClown::result() const {
  return result_;
}
inline void AckCloseClown::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// AckServerInMaintaining

// -------------------------------------------------------------------

// AckPoolValue

// required uint64 poolValue = 1;
inline bool AckPoolValue::has_poolvalue() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckPoolValue::set_has_poolvalue() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckPoolValue::clear_has_poolvalue() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckPoolValue::clear_poolvalue() {
  poolvalue_ = GOOGLE_ULONGLONG(0);
  clear_has_poolvalue();
}
inline ::google::protobuf::uint64 AckPoolValue::poolvalue() const {
  return poolvalue_;
}
inline void AckPoolValue::set_poolvalue(::google::protobuf::uint64 value) {
  set_has_poolvalue();
  poolvalue_ = value;
}

// -------------------------------------------------------------------

// ReqRankingList

// required uint32 days = 1;
inline bool ReqRankingList::has_days() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqRankingList::set_has_days() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqRankingList::clear_has_days() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqRankingList::clear_days() {
  days_ = 0u;
  clear_has_days();
}
inline ::google::protobuf::uint32 ReqRankingList::days() const {
  return days_;
}
inline void ReqRankingList::set_days(::google::protobuf::uint32 value) {
  set_has_days();
  days_ = value;
}

// required uint32 type = 2;
inline bool ReqRankingList::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqRankingList::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqRankingList::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqRankingList::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 ReqRankingList::type() const {
  return type_;
}
inline void ReqRankingList::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional uint32 number = 3 [default = 10];
inline bool ReqRankingList::has_number() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqRankingList::set_has_number() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqRankingList::clear_has_number() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqRankingList::clear_number() {
  number_ = 10u;
  clear_has_number();
}
inline ::google::protobuf::uint32 ReqRankingList::number() const {
  return number_;
}
inline void ReqRankingList::set_number(::google::protobuf::uint32 value) {
  set_has_number();
  number_ = value;
}

// optional bool containSelf = 4 [default = true];
inline bool ReqRankingList::has_containself() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReqRankingList::set_has_containself() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReqRankingList::clear_has_containself() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReqRankingList::clear_containself() {
  containself_ = true;
  clear_has_containself();
}
inline bool ReqRankingList::containself() const {
  return containself_;
}
inline void ReqRankingList::set_containself(bool value) {
  set_has_containself();
  containself_ = value;
}

// optional bool strictChannel = 5 [default = false];
inline bool ReqRankingList::has_strictchannel() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReqRankingList::set_has_strictchannel() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReqRankingList::clear_has_strictchannel() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReqRankingList::clear_strictchannel() {
  strictchannel_ = false;
  clear_has_strictchannel();
}
inline bool ReqRankingList::strictchannel() const {
  return strictchannel_;
}
inline void ReqRankingList::set_strictchannel(bool value) {
  set_has_strictchannel();
  strictchannel_ = value;
}

// -------------------------------------------------------------------

// AckRankingList_RankInfo

// required uint32 serial = 1;
inline bool AckRankingList_RankInfo::has_serial() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckRankingList_RankInfo::set_has_serial() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckRankingList_RankInfo::clear_has_serial() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckRankingList_RankInfo::clear_serial() {
  serial_ = 0u;
  clear_has_serial();
}
inline ::google::protobuf::uint32 AckRankingList_RankInfo::serial() const {
  return serial_;
}
inline void AckRankingList_RankInfo::set_serial(::google::protobuf::uint32 value) {
  set_has_serial();
  serial_ = value;
}

// required uint64 userId = 2;
inline bool AckRankingList_RankInfo::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckRankingList_RankInfo::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckRankingList_RankInfo::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckRankingList_RankInfo::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 AckRankingList_RankInfo::userid() const {
  return userid_;
}
inline void AckRankingList_RankInfo::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// required string roleName = 3;
inline bool AckRankingList_RankInfo::has_rolename() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckRankingList_RankInfo::set_has_rolename() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckRankingList_RankInfo::clear_has_rolename() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckRankingList_RankInfo::clear_rolename() {
  if (rolename_ != &::google::protobuf::internal::kEmptyString) {
    rolename_->clear();
  }
  clear_has_rolename();
}
inline const ::std::string& AckRankingList_RankInfo::rolename() const {
  return *rolename_;
}
inline void AckRankingList_RankInfo::set_rolename(const ::std::string& value) {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  rolename_->assign(value);
}
inline void AckRankingList_RankInfo::set_rolename(const char* value) {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  rolename_->assign(value);
}
inline void AckRankingList_RankInfo::set_rolename(const char* value, size_t size) {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  rolename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckRankingList_RankInfo::mutable_rolename() {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  return rolename_;
}
inline ::std::string* AckRankingList_RankInfo::release_rolename() {
  clear_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rolename_;
    rolename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int64 value = 4;
inline bool AckRankingList_RankInfo::has_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AckRankingList_RankInfo::set_has_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AckRankingList_RankInfo::clear_has_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AckRankingList_RankInfo::clear_value() {
  value_ = GOOGLE_LONGLONG(0);
  clear_has_value();
}
inline ::google::protobuf::int64 AckRankingList_RankInfo::value() const {
  return value_;
}
inline void AckRankingList_RankInfo::set_value(::google::protobuf::int64 value) {
  set_has_value();
  value_ = value;
}

// required uint64 subValue = 5;
inline bool AckRankingList_RankInfo::has_subvalue() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AckRankingList_RankInfo::set_has_subvalue() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AckRankingList_RankInfo::clear_has_subvalue() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AckRankingList_RankInfo::clear_subvalue() {
  subvalue_ = GOOGLE_ULONGLONG(0);
  clear_has_subvalue();
}
inline ::google::protobuf::uint64 AckRankingList_RankInfo::subvalue() const {
  return subvalue_;
}
inline void AckRankingList_RankInfo::set_subvalue(::google::protobuf::uint64 value) {
  set_has_subvalue();
  subvalue_ = value;
}

// -------------------------------------------------------------------

// AckRankingList

// required uint32 type = 1;
inline bool AckRankingList::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckRankingList::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckRankingList::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckRankingList::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 AckRankingList::type() const {
  return type_;
}
inline void AckRankingList::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional uint32 channel = 2;
inline bool AckRankingList::has_channel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckRankingList::set_has_channel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckRankingList::clear_has_channel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckRankingList::clear_channel() {
  channel_ = 0u;
  clear_has_channel();
}
inline ::google::protobuf::uint32 AckRankingList::channel() const {
  return channel_;
}
inline void AckRankingList::set_channel(::google::protobuf::uint32 value) {
  set_has_channel();
  channel_ = value;
}

// repeated .com.ourgame.clown.msg.AckRankingList.RankInfo list = 3;
inline int AckRankingList::list_size() const {
  return list_.size();
}
inline void AckRankingList::clear_list() {
  list_.Clear();
}
inline const ::com::ourgame::clown::msg::AckRankingList_RankInfo& AckRankingList::list(int index) const {
  return list_.Get(index);
}
inline ::com::ourgame::clown::msg::AckRankingList_RankInfo* AckRankingList::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::com::ourgame::clown::msg::AckRankingList_RankInfo* AckRankingList::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::ourgame::clown::msg::AckRankingList_RankInfo >&
AckRankingList::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::ourgame::clown::msg::AckRankingList_RankInfo >*
AckRankingList::mutable_list() {
  return &list_;
}

// -------------------------------------------------------------------

// ReqHandselAwardHistory

// optional uint32 type = 1;
inline bool ReqHandselAwardHistory::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqHandselAwardHistory::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqHandselAwardHistory::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqHandselAwardHistory::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 ReqHandselAwardHistory::type() const {
  return type_;
}
inline void ReqHandselAwardHistory::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional uint32 rows = 2 [default = 20];
inline bool ReqHandselAwardHistory::has_rows() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqHandselAwardHistory::set_has_rows() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqHandselAwardHistory::clear_has_rows() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqHandselAwardHistory::clear_rows() {
  rows_ = 20u;
  clear_has_rows();
}
inline ::google::protobuf::uint32 ReqHandselAwardHistory::rows() const {
  return rows_;
}
inline void ReqHandselAwardHistory::set_rows(::google::protobuf::uint32 value) {
  set_has_rows();
  rows_ = value;
}

// -------------------------------------------------------------------

// AckHandselAwardHistory_HandselAward

// required uint32 serial = 1;
inline bool AckHandselAwardHistory_HandselAward::has_serial() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckHandselAwardHistory_HandselAward::set_has_serial() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckHandselAwardHistory_HandselAward::clear_has_serial() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckHandselAwardHistory_HandselAward::clear_serial() {
  serial_ = 0u;
  clear_has_serial();
}
inline ::google::protobuf::uint32 AckHandselAwardHistory_HandselAward::serial() const {
  return serial_;
}
inline void AckHandselAwardHistory_HandselAward::set_serial(::google::protobuf::uint32 value) {
  set_has_serial();
  serial_ = value;
}

// required string username = 2;
inline bool AckHandselAwardHistory_HandselAward::has_username() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckHandselAwardHistory_HandselAward::set_has_username() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckHandselAwardHistory_HandselAward::clear_has_username() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckHandselAwardHistory_HandselAward::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& AckHandselAwardHistory_HandselAward::username() const {
  return *username_;
}
inline void AckHandselAwardHistory_HandselAward::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void AckHandselAwardHistory_HandselAward::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void AckHandselAwardHistory_HandselAward::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckHandselAwardHistory_HandselAward::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* AckHandselAwardHistory_HandselAward::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string happenTime = 3;
inline bool AckHandselAwardHistory_HandselAward::has_happentime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckHandselAwardHistory_HandselAward::set_has_happentime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckHandselAwardHistory_HandselAward::clear_has_happentime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckHandselAwardHistory_HandselAward::clear_happentime() {
  if (happentime_ != &::google::protobuf::internal::kEmptyString) {
    happentime_->clear();
  }
  clear_has_happentime();
}
inline const ::std::string& AckHandselAwardHistory_HandselAward::happentime() const {
  return *happentime_;
}
inline void AckHandselAwardHistory_HandselAward::set_happentime(const ::std::string& value) {
  set_has_happentime();
  if (happentime_ == &::google::protobuf::internal::kEmptyString) {
    happentime_ = new ::std::string;
  }
  happentime_->assign(value);
}
inline void AckHandselAwardHistory_HandselAward::set_happentime(const char* value) {
  set_has_happentime();
  if (happentime_ == &::google::protobuf::internal::kEmptyString) {
    happentime_ = new ::std::string;
  }
  happentime_->assign(value);
}
inline void AckHandselAwardHistory_HandselAward::set_happentime(const char* value, size_t size) {
  set_has_happentime();
  if (happentime_ == &::google::protobuf::internal::kEmptyString) {
    happentime_ = new ::std::string;
  }
  happentime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckHandselAwardHistory_HandselAward::mutable_happentime() {
  set_has_happentime();
  if (happentime_ == &::google::protobuf::internal::kEmptyString) {
    happentime_ = new ::std::string;
  }
  return happentime_;
}
inline ::std::string* AckHandselAwardHistory_HandselAward::release_happentime() {
  clear_has_happentime();
  if (happentime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = happentime_;
    happentime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required uint64 awardMoney = 4;
inline bool AckHandselAwardHistory_HandselAward::has_awardmoney() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AckHandselAwardHistory_HandselAward::set_has_awardmoney() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AckHandselAwardHistory_HandselAward::clear_has_awardmoney() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AckHandselAwardHistory_HandselAward::clear_awardmoney() {
  awardmoney_ = GOOGLE_ULONGLONG(0);
  clear_has_awardmoney();
}
inline ::google::protobuf::uint64 AckHandselAwardHistory_HandselAward::awardmoney() const {
  return awardmoney_;
}
inline void AckHandselAwardHistory_HandselAward::set_awardmoney(::google::protobuf::uint64 value) {
  set_has_awardmoney();
  awardmoney_ = value;
}

// required uint64 handselPool = 5;
inline bool AckHandselAwardHistory_HandselAward::has_handselpool() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AckHandselAwardHistory_HandselAward::set_has_handselpool() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AckHandselAwardHistory_HandselAward::clear_has_handselpool() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AckHandselAwardHistory_HandselAward::clear_handselpool() {
  handselpool_ = GOOGLE_ULONGLONG(0);
  clear_has_handselpool();
}
inline ::google::protobuf::uint64 AckHandselAwardHistory_HandselAward::handselpool() const {
  return handselpool_;
}
inline void AckHandselAwardHistory_HandselAward::set_handselpool(::google::protobuf::uint64 value) {
  set_has_handselpool();
  handselpool_ = value;
}

// -------------------------------------------------------------------

// AckHandselAwardHistory

// required uint32 type = 1 [default = 0];
inline bool AckHandselAwardHistory::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckHandselAwardHistory::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckHandselAwardHistory::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckHandselAwardHistory::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 AckHandselAwardHistory::type() const {
  return type_;
}
inline void AckHandselAwardHistory::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// repeated .com.ourgame.clown.msg.AckHandselAwardHistory.HandselAward history = 2;
inline int AckHandselAwardHistory::history_size() const {
  return history_.size();
}
inline void AckHandselAwardHistory::clear_history() {
  history_.Clear();
}
inline const ::com::ourgame::clown::msg::AckHandselAwardHistory_HandselAward& AckHandselAwardHistory::history(int index) const {
  return history_.Get(index);
}
inline ::com::ourgame::clown::msg::AckHandselAwardHistory_HandselAward* AckHandselAwardHistory::mutable_history(int index) {
  return history_.Mutable(index);
}
inline ::com::ourgame::clown::msg::AckHandselAwardHistory_HandselAward* AckHandselAwardHistory::add_history() {
  return history_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::ourgame::clown::msg::AckHandselAwardHistory_HandselAward >&
AckHandselAwardHistory::history() const {
  return history_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::ourgame::clown::msg::AckHandselAwardHistory_HandselAward >*
AckHandselAwardHistory::mutable_history() {
  return &history_;
}

// -------------------------------------------------------------------

// AckIncreaseExpActivity

// required int32 level = 1;
inline bool AckIncreaseExpActivity::has_level() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckIncreaseExpActivity::set_has_level() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckIncreaseExpActivity::clear_has_level() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckIncreaseExpActivity::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 AckIncreaseExpActivity::level() const {
  return level_;
}
inline void AckIncreaseExpActivity::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// required int32 orLev = 2;
inline bool AckIncreaseExpActivity::has_orlev() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckIncreaseExpActivity::set_has_orlev() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckIncreaseExpActivity::clear_has_orlev() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckIncreaseExpActivity::clear_orlev() {
  orlev_ = 0;
  clear_has_orlev();
}
inline ::google::protobuf::int32 AckIncreaseExpActivity::orlev() const {
  return orlev_;
}
inline void AckIncreaseExpActivity::set_orlev(::google::protobuf::int32 value) {
  set_has_orlev();
  orlev_ = value;
}

// required int64 award = 3;
inline bool AckIncreaseExpActivity::has_award() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckIncreaseExpActivity::set_has_award() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckIncreaseExpActivity::clear_has_award() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckIncreaseExpActivity::clear_award() {
  award_ = GOOGLE_LONGLONG(0);
  clear_has_award();
}
inline ::google::protobuf::int64 AckIncreaseExpActivity::award() const {
  return award_;
}
inline void AckIncreaseExpActivity::set_award(::google::protobuf::int64 value) {
  set_has_award();
  award_ = value;
}

// required int64 curExp = 4;
inline bool AckIncreaseExpActivity::has_curexp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AckIncreaseExpActivity::set_has_curexp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AckIncreaseExpActivity::clear_has_curexp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AckIncreaseExpActivity::clear_curexp() {
  curexp_ = GOOGLE_LONGLONG(0);
  clear_has_curexp();
}
inline ::google::protobuf::int64 AckIncreaseExpActivity::curexp() const {
  return curexp_;
}
inline void AckIncreaseExpActivity::set_curexp(::google::protobuf::int64 value) {
  set_has_curexp();
  curexp_ = value;
}

// required int64 maxExp = 5;
inline bool AckIncreaseExpActivity::has_maxexp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AckIncreaseExpActivity::set_has_maxexp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AckIncreaseExpActivity::clear_has_maxexp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AckIncreaseExpActivity::clear_maxexp() {
  maxexp_ = GOOGLE_LONGLONG(0);
  clear_has_maxexp();
}
inline ::google::protobuf::int64 AckIncreaseExpActivity::maxexp() const {
  return maxexp_;
}
inline void AckIncreaseExpActivity::set_maxexp(::google::protobuf::int64 value) {
  set_has_maxexp();
  maxexp_ = value;
}

// required string title = 6;
inline bool AckIncreaseExpActivity::has_title() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AckIncreaseExpActivity::set_has_title() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AckIncreaseExpActivity::clear_has_title() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AckIncreaseExpActivity::clear_title() {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& AckIncreaseExpActivity::title() const {
  return *title_;
}
inline void AckIncreaseExpActivity::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void AckIncreaseExpActivity::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void AckIncreaseExpActivity::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckIncreaseExpActivity::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  return title_;
}
inline ::std::string* AckIncreaseExpActivity::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ReqDegrade

// -------------------------------------------------------------------

// ReqNewActivityInfo

// -------------------------------------------------------------------

// AckNewActivityInfo_NewActivity

// required int32 actId = 1;
inline bool AckNewActivityInfo_NewActivity::has_actid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckNewActivityInfo_NewActivity::set_has_actid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckNewActivityInfo_NewActivity::clear_has_actid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckNewActivityInfo_NewActivity::clear_actid() {
  actid_ = 0;
  clear_has_actid();
}
inline ::google::protobuf::int32 AckNewActivityInfo_NewActivity::actid() const {
  return actid_;
}
inline void AckNewActivityInfo_NewActivity::set_actid(::google::protobuf::int32 value) {
  set_has_actid();
  actid_ = value;
}

// required bool open = 2;
inline bool AckNewActivityInfo_NewActivity::has_open() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckNewActivityInfo_NewActivity::set_has_open() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckNewActivityInfo_NewActivity::clear_has_open() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckNewActivityInfo_NewActivity::clear_open() {
  open_ = false;
  clear_has_open();
}
inline bool AckNewActivityInfo_NewActivity::open() const {
  return open_;
}
inline void AckNewActivityInfo_NewActivity::set_open(bool value) {
  set_has_open();
  open_ = value;
}

// required string title = 3;
inline bool AckNewActivityInfo_NewActivity::has_title() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckNewActivityInfo_NewActivity::set_has_title() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckNewActivityInfo_NewActivity::clear_has_title() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckNewActivityInfo_NewActivity::clear_title() {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& AckNewActivityInfo_NewActivity::title() const {
  return *title_;
}
inline void AckNewActivityInfo_NewActivity::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void AckNewActivityInfo_NewActivity::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void AckNewActivityInfo_NewActivity::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckNewActivityInfo_NewActivity::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  return title_;
}
inline ::std::string* AckNewActivityInfo_NewActivity::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int64 curExp = 4;
inline bool AckNewActivityInfo_NewActivity::has_curexp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AckNewActivityInfo_NewActivity::set_has_curexp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AckNewActivityInfo_NewActivity::clear_has_curexp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AckNewActivityInfo_NewActivity::clear_curexp() {
  curexp_ = GOOGLE_LONGLONG(0);
  clear_has_curexp();
}
inline ::google::protobuf::int64 AckNewActivityInfo_NewActivity::curexp() const {
  return curexp_;
}
inline void AckNewActivityInfo_NewActivity::set_curexp(::google::protobuf::int64 value) {
  set_has_curexp();
  curexp_ = value;
}

// required int64 maxExp = 5;
inline bool AckNewActivityInfo_NewActivity::has_maxexp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AckNewActivityInfo_NewActivity::set_has_maxexp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AckNewActivityInfo_NewActivity::clear_has_maxexp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AckNewActivityInfo_NewActivity::clear_maxexp() {
  maxexp_ = GOOGLE_LONGLONG(0);
  clear_has_maxexp();
}
inline ::google::protobuf::int64 AckNewActivityInfo_NewActivity::maxexp() const {
  return maxexp_;
}
inline void AckNewActivityInfo_NewActivity::set_maxexp(::google::protobuf::int64 value) {
  set_has_maxexp();
  maxexp_ = value;
}

// -------------------------------------------------------------------

// AckNewActivityInfo

// repeated .com.ourgame.clown.msg.AckNewActivityInfo.NewActivity newActivityList = 1;
inline int AckNewActivityInfo::newactivitylist_size() const {
  return newactivitylist_.size();
}
inline void AckNewActivityInfo::clear_newactivitylist() {
  newactivitylist_.Clear();
}
inline const ::com::ourgame::clown::msg::AckNewActivityInfo_NewActivity& AckNewActivityInfo::newactivitylist(int index) const {
  return newactivitylist_.Get(index);
}
inline ::com::ourgame::clown::msg::AckNewActivityInfo_NewActivity* AckNewActivityInfo::mutable_newactivitylist(int index) {
  return newactivitylist_.Mutable(index);
}
inline ::com::ourgame::clown::msg::AckNewActivityInfo_NewActivity* AckNewActivityInfo::add_newactivitylist() {
  return newactivitylist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::ourgame::clown::msg::AckNewActivityInfo_NewActivity >&
AckNewActivityInfo::newactivitylist() const {
  return newactivitylist_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::ourgame::clown::msg::AckNewActivityInfo_NewActivity >*
AckNewActivityInfo::mutable_newactivitylist() {
  return &newactivitylist_;
}

// -------------------------------------------------------------------

// ReqBox

// -------------------------------------------------------------------

// AckBox

// required int64 award = 1;
inline bool AckBox::has_award() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckBox::set_has_award() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckBox::clear_has_award() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckBox::clear_award() {
  award_ = GOOGLE_LONGLONG(0);
  clear_has_award();
}
inline ::google::protobuf::int64 AckBox::award() const {
  return award_;
}
inline void AckBox::set_award(::google::protobuf::int64 value) {
  set_has_award();
  award_ = value;
}

// required int32 boxCount = 2;
inline bool AckBox::has_boxcount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckBox::set_has_boxcount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckBox::clear_has_boxcount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckBox::clear_boxcount() {
  boxcount_ = 0;
  clear_has_boxcount();
}
inline ::google::protobuf::int32 AckBox::boxcount() const {
  return boxcount_;
}
inline void AckBox::set_boxcount(::google::protobuf::int32 value) {
  set_has_boxcount();
  boxcount_ = value;
}

// -------------------------------------------------------------------

// AckUserMoney

// required int64 userMoney = 1;
inline bool AckUserMoney::has_usermoney() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckUserMoney::set_has_usermoney() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckUserMoney::clear_has_usermoney() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckUserMoney::clear_usermoney() {
  usermoney_ = GOOGLE_LONGLONG(0);
  clear_has_usermoney();
}
inline ::google::protobuf::int64 AckUserMoney::usermoney() const {
  return usermoney_;
}
inline void AckUserMoney::set_usermoney(::google::protobuf::int64 value) {
  set_has_usermoney();
  usermoney_ = value;
}

// -------------------------------------------------------------------

// AckDegradeTime

// required int32 remainTime = 1;
inline bool AckDegradeTime::has_remaintime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckDegradeTime::set_has_remaintime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckDegradeTime::clear_has_remaintime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckDegradeTime::clear_remaintime() {
  remaintime_ = 0;
  clear_has_remaintime();
}
inline ::google::protobuf::int32 AckDegradeTime::remaintime() const {
  return remaintime_;
}
inline void AckDegradeTime::set_remaintime(::google::protobuf::int32 value) {
  set_has_remaintime();
  remaintime_ = value;
}

// -------------------------------------------------------------------

// ReqOrAccordRecharge

// required string username = 1;
inline bool ReqOrAccordRecharge::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqOrAccordRecharge::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqOrAccordRecharge::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqOrAccordRecharge::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& ReqOrAccordRecharge::username() const {
  return *username_;
}
inline void ReqOrAccordRecharge::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void ReqOrAccordRecharge::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void ReqOrAccordRecharge::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqOrAccordRecharge::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* ReqOrAccordRecharge::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AckOrAccordRecharge

// required int32 orCan = 1;
inline bool AckOrAccordRecharge::has_orcan() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckOrAccordRecharge::set_has_orcan() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckOrAccordRecharge::clear_has_orcan() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckOrAccordRecharge::clear_orcan() {
  orcan_ = 0;
  clear_has_orcan();
}
inline ::google::protobuf::int32 AckOrAccordRecharge::orcan() const {
  return orcan_;
}
inline void AckOrAccordRecharge::set_orcan(::google::protobuf::int32 value) {
  set_has_orcan();
  orcan_ = value;
}

// -------------------------------------------------------------------

// ReqAuthCode

// required string username = 1;
inline bool ReqAuthCode::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqAuthCode::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqAuthCode::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqAuthCode::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& ReqAuthCode::username() const {
  return *username_;
}
inline void ReqAuthCode::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void ReqAuthCode::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void ReqAuthCode::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqAuthCode::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* ReqAuthCode::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string tel = 2;
inline bool ReqAuthCode::has_tel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqAuthCode::set_has_tel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqAuthCode::clear_has_tel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqAuthCode::clear_tel() {
  if (tel_ != &::google::protobuf::internal::kEmptyString) {
    tel_->clear();
  }
  clear_has_tel();
}
inline const ::std::string& ReqAuthCode::tel() const {
  return *tel_;
}
inline void ReqAuthCode::set_tel(const ::std::string& value) {
  set_has_tel();
  if (tel_ == &::google::protobuf::internal::kEmptyString) {
    tel_ = new ::std::string;
  }
  tel_->assign(value);
}
inline void ReqAuthCode::set_tel(const char* value) {
  set_has_tel();
  if (tel_ == &::google::protobuf::internal::kEmptyString) {
    tel_ = new ::std::string;
  }
  tel_->assign(value);
}
inline void ReqAuthCode::set_tel(const char* value, size_t size) {
  set_has_tel();
  if (tel_ == &::google::protobuf::internal::kEmptyString) {
    tel_ = new ::std::string;
  }
  tel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqAuthCode::mutable_tel() {
  set_has_tel();
  if (tel_ == &::google::protobuf::internal::kEmptyString) {
    tel_ = new ::std::string;
  }
  return tel_;
}
inline ::std::string* ReqAuthCode::release_tel() {
  clear_has_tel();
  if (tel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tel_;
    tel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AckAuthCode

// required int32 sucess = 1;
inline bool AckAuthCode::has_sucess() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckAuthCode::set_has_sucess() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckAuthCode::clear_has_sucess() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckAuthCode::clear_sucess() {
  sucess_ = 0;
  clear_has_sucess();
}
inline ::google::protobuf::int32 AckAuthCode::sucess() const {
  return sucess_;
}
inline void AckAuthCode::set_sucess(::google::protobuf::int32 value) {
  set_has_sucess();
  sucess_ = value;
}

// required string reason = 3;
inline bool AckAuthCode::has_reason() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckAuthCode::set_has_reason() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckAuthCode::clear_has_reason() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckAuthCode::clear_reason() {
  if (reason_ != &::google::protobuf::internal::kEmptyString) {
    reason_->clear();
  }
  clear_has_reason();
}
inline const ::std::string& AckAuthCode::reason() const {
  return *reason_;
}
inline void AckAuthCode::set_reason(const ::std::string& value) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
}
inline void AckAuthCode::set_reason(const char* value) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
}
inline void AckAuthCode::set_reason(const char* value, size_t size) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    reason_ = new ::std::string;
  }
  reason_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckAuthCode::mutable_reason() {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    reason_ = new ::std::string;
  }
  return reason_;
}
inline ::std::string* AckAuthCode::release_reason() {
  clear_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = reason_;
    reason_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ReqUserRecharge

// required string username = 1;
inline bool ReqUserRecharge::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqUserRecharge::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqUserRecharge::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqUserRecharge::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& ReqUserRecharge::username() const {
  return *username_;
}
inline void ReqUserRecharge::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void ReqUserRecharge::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void ReqUserRecharge::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqUserRecharge::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* ReqUserRecharge::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string authCode = 2;
inline bool ReqUserRecharge::has_authcode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqUserRecharge::set_has_authcode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqUserRecharge::clear_has_authcode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqUserRecharge::clear_authcode() {
  if (authcode_ != &::google::protobuf::internal::kEmptyString) {
    authcode_->clear();
  }
  clear_has_authcode();
}
inline const ::std::string& ReqUserRecharge::authcode() const {
  return *authcode_;
}
inline void ReqUserRecharge::set_authcode(const ::std::string& value) {
  set_has_authcode();
  if (authcode_ == &::google::protobuf::internal::kEmptyString) {
    authcode_ = new ::std::string;
  }
  authcode_->assign(value);
}
inline void ReqUserRecharge::set_authcode(const char* value) {
  set_has_authcode();
  if (authcode_ == &::google::protobuf::internal::kEmptyString) {
    authcode_ = new ::std::string;
  }
  authcode_->assign(value);
}
inline void ReqUserRecharge::set_authcode(const char* value, size_t size) {
  set_has_authcode();
  if (authcode_ == &::google::protobuf::internal::kEmptyString) {
    authcode_ = new ::std::string;
  }
  authcode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqUserRecharge::mutable_authcode() {
  set_has_authcode();
  if (authcode_ == &::google::protobuf::internal::kEmptyString) {
    authcode_ = new ::std::string;
  }
  return authcode_;
}
inline ::std::string* ReqUserRecharge::release_authcode() {
  clear_has_authcode();
  if (authcode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = authcode_;
    authcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AckUserRecharge

// required int64 frecharge = 1;
inline bool AckUserRecharge::has_frecharge() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckUserRecharge::set_has_frecharge() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckUserRecharge::clear_has_frecharge() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckUserRecharge::clear_frecharge() {
  frecharge_ = GOOGLE_LONGLONG(0);
  clear_has_frecharge();
}
inline ::google::protobuf::int64 AckUserRecharge::frecharge() const {
  return frecharge_;
}
inline void AckUserRecharge::set_frecharge(::google::protobuf::int64 value) {
  set_has_frecharge();
  frecharge_ = value;
}

// required int64 money = 2;
inline bool AckUserRecharge::has_money() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckUserRecharge::set_has_money() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckUserRecharge::clear_has_money() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckUserRecharge::clear_money() {
  money_ = GOOGLE_LONGLONG(0);
  clear_has_money();
}
inline ::google::protobuf::int64 AckUserRecharge::money() const {
  return money_;
}
inline void AckUserRecharge::set_money(::google::protobuf::int64 value) {
  set_has_money();
  money_ = value;
}

// required int32 times = 3;
inline bool AckUserRecharge::has_times() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckUserRecharge::set_has_times() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckUserRecharge::clear_has_times() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckUserRecharge::clear_times() {
  times_ = 0;
  clear_has_times();
}
inline ::google::protobuf::int32 AckUserRecharge::times() const {
  return times_;
}
inline void AckUserRecharge::set_times(::google::protobuf::int32 value) {
  set_has_times();
  times_ = value;
}

// -------------------------------------------------------------------

// ReqMobleRecharge

// required string username = 1;
inline bool ReqMobleRecharge::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqMobleRecharge::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqMobleRecharge::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqMobleRecharge::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& ReqMobleRecharge::username() const {
  return *username_;
}
inline void ReqMobleRecharge::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void ReqMobleRecharge::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void ReqMobleRecharge::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqMobleRecharge::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* ReqMobleRecharge::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AckMobleRecharge

// required int32 success = 1;
inline bool AckMobleRecharge::has_success() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckMobleRecharge::set_has_success() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckMobleRecharge::clear_has_success() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckMobleRecharge::clear_success() {
  success_ = 0;
  clear_has_success();
}
inline ::google::protobuf::int32 AckMobleRecharge::success() const {
  return success_;
}
inline void AckMobleRecharge::set_success(::google::protobuf::int32 value) {
  set_has_success();
  success_ = value;
}

// optional string reason = 2;
inline bool AckMobleRecharge::has_reason() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckMobleRecharge::set_has_reason() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckMobleRecharge::clear_has_reason() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckMobleRecharge::clear_reason() {
  if (reason_ != &::google::protobuf::internal::kEmptyString) {
    reason_->clear();
  }
  clear_has_reason();
}
inline const ::std::string& AckMobleRecharge::reason() const {
  return *reason_;
}
inline void AckMobleRecharge::set_reason(const ::std::string& value) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
}
inline void AckMobleRecharge::set_reason(const char* value) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
}
inline void AckMobleRecharge::set_reason(const char* value, size_t size) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    reason_ = new ::std::string;
  }
  reason_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckMobleRecharge::mutable_reason() {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    reason_ = new ::std::string;
  }
  return reason_;
}
inline ::std::string* AckMobleRecharge::release_reason() {
  clear_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = reason_;
    reason_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int64 money = 3;
inline bool AckMobleRecharge::has_money() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckMobleRecharge::set_has_money() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckMobleRecharge::clear_has_money() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckMobleRecharge::clear_money() {
  money_ = GOOGLE_LONGLONG(0);
  clear_has_money();
}
inline ::google::protobuf::int64 AckMobleRecharge::money() const {
  return money_;
}
inline void AckMobleRecharge::set_money(::google::protobuf::int64 value) {
  set_has_money();
  money_ = value;
}

// -------------------------------------------------------------------

// ReqPopMobleRecharge

// required string username = 1;
inline bool ReqPopMobleRecharge::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqPopMobleRecharge::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqPopMobleRecharge::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqPopMobleRecharge::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& ReqPopMobleRecharge::username() const {
  return *username_;
}
inline void ReqPopMobleRecharge::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void ReqPopMobleRecharge::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void ReqPopMobleRecharge::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqPopMobleRecharge::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* ReqPopMobleRecharge::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AckPopMobleRecharge

// required int32 result = 1;
inline bool AckPopMobleRecharge::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckPopMobleRecharge::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckPopMobleRecharge::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckPopMobleRecharge::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 AckPopMobleRecharge::result() const {
  return result_;
}
inline void AckPopMobleRecharge::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// AckWndAwardNotice

// required int64 wndCount = 1;
inline bool AckWndAwardNotice::has_wndcount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckWndAwardNotice::set_has_wndcount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckWndAwardNotice::clear_has_wndcount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckWndAwardNotice::clear_wndcount() {
  wndcount_ = GOOGLE_LONGLONG(0);
  clear_has_wndcount();
}
inline ::google::protobuf::int64 AckWndAwardNotice::wndcount() const {
  return wndcount_;
}
inline void AckWndAwardNotice::set_wndcount(::google::protobuf::int64 value) {
  set_has_wndcount();
  wndcount_ = value;
}

// required int64 yxdCount = 2;
inline bool AckWndAwardNotice::has_yxdcount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckWndAwardNotice::set_has_yxdcount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckWndAwardNotice::clear_has_yxdcount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckWndAwardNotice::clear_yxdcount() {
  yxdcount_ = GOOGLE_LONGLONG(0);
  clear_has_yxdcount();
}
inline ::google::protobuf::int64 AckWndAwardNotice::yxdcount() const {
  return yxdcount_;
}
inline void AckWndAwardNotice::set_yxdcount(::google::protobuf::int64 value) {
  set_has_yxdcount();
  yxdcount_ = value;
}

// required int32 noticeType = 3;
inline bool AckWndAwardNotice::has_noticetype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckWndAwardNotice::set_has_noticetype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckWndAwardNotice::clear_has_noticetype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckWndAwardNotice::clear_noticetype() {
  noticetype_ = 0;
  clear_has_noticetype();
}
inline ::google::protobuf::int32 AckWndAwardNotice::noticetype() const {
  return noticetype_;
}
inline void AckWndAwardNotice::set_noticetype(::google::protobuf::int32 value) {
  set_has_noticetype();
  noticetype_ = value;
}

// -------------------------------------------------------------------

// ReqNewGuideResult

// required string username = 1;
inline bool ReqNewGuideResult::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqNewGuideResult::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqNewGuideResult::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqNewGuideResult::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& ReqNewGuideResult::username() const {
  return *username_;
}
inline void ReqNewGuideResult::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void ReqNewGuideResult::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void ReqNewGuideResult::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqNewGuideResult::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* ReqNewGuideResult::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 result = 2;
inline bool ReqNewGuideResult::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqNewGuideResult::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqNewGuideResult::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqNewGuideResult::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ReqNewGuideResult::result() const {
  return result_;
}
inline void ReqNewGuideResult::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// ackLotteryAward

// required int64 sessionId = 1;
inline bool ackLotteryAward::has_sessionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ackLotteryAward::set_has_sessionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ackLotteryAward::clear_has_sessionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ackLotteryAward::clear_sessionid() {
  sessionid_ = GOOGLE_LONGLONG(0);
  clear_has_sessionid();
}
inline ::google::protobuf::int64 ackLotteryAward::sessionid() const {
  return sessionid_;
}
inline void ackLotteryAward::set_sessionid(::google::protobuf::int64 value) {
  set_has_sessionid();
  sessionid_ = value;
}

// required string patterns = 2;
inline bool ackLotteryAward::has_patterns() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ackLotteryAward::set_has_patterns() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ackLotteryAward::clear_has_patterns() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ackLotteryAward::clear_patterns() {
  if (patterns_ != &::google::protobuf::internal::kEmptyString) {
    patterns_->clear();
  }
  clear_has_patterns();
}
inline const ::std::string& ackLotteryAward::patterns() const {
  return *patterns_;
}
inline void ackLotteryAward::set_patterns(const ::std::string& value) {
  set_has_patterns();
  if (patterns_ == &::google::protobuf::internal::kEmptyString) {
    patterns_ = new ::std::string;
  }
  patterns_->assign(value);
}
inline void ackLotteryAward::set_patterns(const char* value) {
  set_has_patterns();
  if (patterns_ == &::google::protobuf::internal::kEmptyString) {
    patterns_ = new ::std::string;
  }
  patterns_->assign(value);
}
inline void ackLotteryAward::set_patterns(const char* value, size_t size) {
  set_has_patterns();
  if (patterns_ == &::google::protobuf::internal::kEmptyString) {
    patterns_ = new ::std::string;
  }
  patterns_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ackLotteryAward::mutable_patterns() {
  set_has_patterns();
  if (patterns_ == &::google::protobuf::internal::kEmptyString) {
    patterns_ = new ::std::string;
  }
  return patterns_;
}
inline ::std::string* ackLotteryAward::release_patterns() {
  clear_has_patterns();
  if (patterns_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = patterns_;
    patterns_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int64 awardMoney = 3;
inline bool ackLotteryAward::has_awardmoney() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ackLotteryAward::set_has_awardmoney() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ackLotteryAward::clear_has_awardmoney() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ackLotteryAward::clear_awardmoney() {
  awardmoney_ = GOOGLE_LONGLONG(0);
  clear_has_awardmoney();
}
inline ::google::protobuf::int64 ackLotteryAward::awardmoney() const {
  return awardmoney_;
}
inline void ackLotteryAward::set_awardmoney(::google::protobuf::int64 value) {
  set_has_awardmoney();
  awardmoney_ = value;
}

// required int64 userMoney = 4;
inline bool ackLotteryAward::has_usermoney() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ackLotteryAward::set_has_usermoney() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ackLotteryAward::clear_has_usermoney() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ackLotteryAward::clear_usermoney() {
  usermoney_ = GOOGLE_LONGLONG(0);
  clear_has_usermoney();
}
inline ::google::protobuf::int64 ackLotteryAward::usermoney() const {
  return usermoney_;
}
inline void ackLotteryAward::set_usermoney(::google::protobuf::int64 value) {
  set_has_usermoney();
  usermoney_ = value;
}

// optional int32 awardIndex = 5;
inline bool ackLotteryAward::has_awardindex() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ackLotteryAward::set_has_awardindex() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ackLotteryAward::clear_has_awardindex() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ackLotteryAward::clear_awardindex() {
  awardindex_ = 0;
  clear_has_awardindex();
}
inline ::google::protobuf::int32 ackLotteryAward::awardindex() const {
  return awardindex_;
}
inline void ackLotteryAward::set_awardindex(::google::protobuf::int32 value) {
  set_has_awardindex();
  awardindex_ = value;
}

// optional int32 playTimes = 6;
inline bool ackLotteryAward::has_playtimes() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ackLotteryAward::set_has_playtimes() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ackLotteryAward::clear_has_playtimes() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ackLotteryAward::clear_playtimes() {
  playtimes_ = 0;
  clear_has_playtimes();
}
inline ::google::protobuf::int32 ackLotteryAward::playtimes() const {
  return playtimes_;
}
inline void ackLotteryAward::set_playtimes(::google::protobuf::int32 value) {
  set_has_playtimes();
  playtimes_ = value;
}

// optional int32 doubleTimes = 7;
inline bool ackLotteryAward::has_doubletimes() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ackLotteryAward::set_has_doubletimes() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ackLotteryAward::clear_has_doubletimes() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ackLotteryAward::clear_doubletimes() {
  doubletimes_ = 0;
  clear_has_doubletimes();
}
inline ::google::protobuf::int32 ackLotteryAward::doubletimes() const {
  return doubletimes_;
}
inline void ackLotteryAward::set_doubletimes(::google::protobuf::int32 value) {
  set_has_doubletimes();
  doubletimes_ = value;
}

// required bool canBet = 8;
inline bool ackLotteryAward::has_canbet() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ackLotteryAward::set_has_canbet() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ackLotteryAward::clear_has_canbet() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ackLotteryAward::clear_canbet() {
  canbet_ = false;
  clear_has_canbet();
}
inline bool ackLotteryAward::canbet() const {
  return canbet_;
}
inline void ackLotteryAward::set_canbet(bool value) {
  set_has_canbet();
  canbet_ = value;
}

// required bool canDoubleBet = 9;
inline bool ackLotteryAward::has_candoublebet() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ackLotteryAward::set_has_candoublebet() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ackLotteryAward::clear_has_candoublebet() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ackLotteryAward::clear_candoublebet() {
  candoublebet_ = false;
  clear_has_candoublebet();
}
inline bool ackLotteryAward::candoublebet() const {
  return candoublebet_;
}
inline void ackLotteryAward::set_candoublebet(bool value) {
  set_has_candoublebet();
  candoublebet_ = value;
}

// required int32 count = 10;
inline bool ackLotteryAward::has_count() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ackLotteryAward::set_has_count() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ackLotteryAward::clear_has_count() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ackLotteryAward::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 ackLotteryAward::count() const {
  return count_;
}
inline void ackLotteryAward::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
}

// -------------------------------------------------------------------

// ReqSendHorn

// optional string username = 1;
inline bool ReqSendHorn::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqSendHorn::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqSendHorn::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqSendHorn::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& ReqSendHorn::username() const {
  return *username_;
}
inline void ReqSendHorn::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void ReqSendHorn::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void ReqSendHorn::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqSendHorn::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* ReqSendHorn::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string contents = 2;
inline bool ReqSendHorn::has_contents() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqSendHorn::set_has_contents() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqSendHorn::clear_has_contents() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqSendHorn::clear_contents() {
  if (contents_ != &::google::protobuf::internal::kEmptyString) {
    contents_->clear();
  }
  clear_has_contents();
}
inline const ::std::string& ReqSendHorn::contents() const {
  return *contents_;
}
inline void ReqSendHorn::set_contents(const ::std::string& value) {
  set_has_contents();
  if (contents_ == &::google::protobuf::internal::kEmptyString) {
    contents_ = new ::std::string;
  }
  contents_->assign(value);
}
inline void ReqSendHorn::set_contents(const char* value) {
  set_has_contents();
  if (contents_ == &::google::protobuf::internal::kEmptyString) {
    contents_ = new ::std::string;
  }
  contents_->assign(value);
}
inline void ReqSendHorn::set_contents(const char* value, size_t size) {
  set_has_contents();
  if (contents_ == &::google::protobuf::internal::kEmptyString) {
    contents_ = new ::std::string;
  }
  contents_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqSendHorn::mutable_contents() {
  set_has_contents();
  if (contents_ == &::google::protobuf::internal::kEmptyString) {
    contents_ = new ::std::string;
  }
  return contents_;
}
inline ::std::string* ReqSendHorn::release_contents() {
  clear_has_contents();
  if (contents_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = contents_;
    contents_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ReqBetFromOthers

// required int64 sessionId = 1;
inline bool ReqBetFromOthers::has_sessionid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqBetFromOthers::set_has_sessionid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqBetFromOthers::clear_has_sessionid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqBetFromOthers::clear_sessionid() {
  sessionid_ = GOOGLE_LONGLONG(0);
  clear_has_sessionid();
}
inline ::google::protobuf::int64 ReqBetFromOthers::sessionid() const {
  return sessionid_;
}
inline void ReqBetFromOthers::set_sessionid(::google::protobuf::int64 value) {
  set_has_sessionid();
  sessionid_ = value;
}

// required int32 betType = 2;
inline bool ReqBetFromOthers::has_bettype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqBetFromOthers::set_has_bettype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqBetFromOthers::clear_has_bettype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqBetFromOthers::clear_bettype() {
  bettype_ = 0;
  clear_has_bettype();
}
inline ::google::protobuf::int32 ReqBetFromOthers::bettype() const {
  return bettype_;
}
inline void ReqBetFromOthers::set_bettype(::google::protobuf::int32 value) {
  set_has_bettype();
  bettype_ = value;
}

// required int64 ante = 3;
inline bool ReqBetFromOthers::has_ante() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqBetFromOthers::set_has_ante() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqBetFromOthers::clear_has_ante() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqBetFromOthers::clear_ante() {
  ante_ = GOOGLE_LONGLONG(0);
  clear_has_ante();
}
inline ::google::protobuf::int64 ReqBetFromOthers::ante() const {
  return ante_;
}
inline void ReqBetFromOthers::set_ante(::google::protobuf::int64 value) {
  set_has_ante();
  ante_ = value;
}

// -------------------------------------------------------------------

// ReqUserMoney

// required string username = 1;
inline bool ReqUserMoney::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqUserMoney::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqUserMoney::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqUserMoney::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& ReqUserMoney::username() const {
  return *username_;
}
inline void ReqUserMoney::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void ReqUserMoney::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void ReqUserMoney::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqUserMoney::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* ReqUserMoney::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace msg
}  // namespace clown
}  // namespace ourgame
}  // namespace com

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ClownServerMessage_2eproto__INCLUDED
